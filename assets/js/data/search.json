[ { "title": "Computer Archithecture | Performance", "url": "/study/computer%20archithecture/1/", "categories": "Study, computer archithecture", "tags": "performance", "date": "2022-03-14 21:00:00 +0900", "snippet": "Performance3/14CPU Time한 컴퓨터 프로그램이 CPU를 차지하여 일을 한 시간Clock Rate (클럭 속도)CPU의 초당 클럭 수, 초당 사이클 수Clock Cycles어떤 일을 수행하기 위해 CPU가 몇개의 clock을 사용하는지CPI (Clock cycles Per Instruction)명령어 하나당 평균 클럭 사이클수---CPI = (CPU Time * Clock Rate) / Instruction Count = Clock Cycles / Instruction Count총 클럭 사이클 수에서 총 명령어 개수를 나누면, 명령어 하나당 평균 클럭 사이클 수가 나올것이다Average cycles per instruction (평균 명렁어 클럭 사이클수)* Determined by CPU hardware  (CPU 하드웨어에 따라서 다름)* If different instructions have different CPI* (다른명령어들이 다른 CPI수를 가지고있다면 평균값에 당연한 영향을 끼침) * Average CPI affected by instruction mixClock Cycle = Instruction Count * Cycles per InstructionCPU Time= CPU Clock Cycles * Clock Cycle Time = CPU Clock Cycles / Clock Rate총 클럭 수에 클럭 사이클 당 실행시간을 곱하면 CPU가 일을 한 시간이 나온다￼클럭 사이클 당 실행시간 * 총 클럭 수CPI는 Clock Per Instruction이고, 여기에 CPI와 I(Instruction)을 곱해서 나타낼 수 있음UnderstandCPU - 1GHz 속도 10개 Instruction 수행1 Instruction당 15 cycle이라면, 10 Instruction?= 150 cycleCPU Time?= 150 (Cycles) * 1GHz/1 (Cycle time)1초에 1G(10^9)번의 rate 이니까 Time은 역수Performance improved by*   Reducing Number of Clock Cycles ( 클럭수의 싸이클수을 줄일때 비로소 성능 업그레이드)*   Increasing clock rate ( 클럭 레이트를 올릴때)*   Hardware designer must often trade off clock rate against cycle count ￼그래서 이제 CPU time이라는 것은, 한 프로그램이 CPU를 차지하여 일을 한 시간을 뜻하는 것이고이는 프로그램 당 명령어 개수, 명령어 하나가 사용하는 사이클 수, 한 사이클 당 소요시간을 곱하면 나온다---암달의 법칙￼E 향상으로 인한 Speedup(성능의 증가)성능의 증가는 곧 실행시간의 감소를 뜻하므로 성능의 증가율을 따질때에는 향상전/향상후 시간이 되는 것이 맞다" }, { "title": "iOS | APP 내 디스플레이 모드 설정하기 (Dark, Light)", "url": "/ios/app/11/", "categories": "iOS, APP", "tags": "dark mode, display, light mode", "date": "2022-03-06 03:20:00 +0900", "snippet": "APP 내 디스플레이 모드 설정하기 (Dark, Light)개인적으로 토이 프로젝트를 진행하다가, 당연히 기본값인 Light Mode로 생각하고 개발을 하고 있었는데, 다크 모드를 사용하고 있는 나의 iPhone에서 실행시키니 background color가 검정색으로 나오고 난리가 났다지금 대응하기에는 이미지도 설정 해야하고 해서 라이트모드로만 실행되도록 하고자 한다앱 디스플레이 모드 설정Project Files - Info.plist아무곳이나 클릭하면 옆에 + 버튼이 생기는데, + 버튼을 눌러준다Key에 해당하는 칸에는 Appearance 를 입력하고 Value에 해당하는 칸에는 원하는 Display Mode 를 적어주면 된다나는 이 앱을 Light Mode로만 실행시키고 싶기 때문에, Light 라고 명시하여 라이트 모드로 실행되도록 제한하였다" }, { "title": "iOS | iPhone Could not launch 오류 해결법", "url": "/ios/app/10/", "categories": "iOS, APP", "tags": "Could not launch, 신뢰하지 않는 개발자", "date": "2022-03-06 02:30:00 +0900", "snippet": "iPhone Couldn’t Launch 오류 해결법다음과 같은 오류는 가상머신이 아닌 자신의 iOS Device를 통하여 프로젝트를 실행시킬 때 발생합니다나의 Device에서는 다음과 같은 오류메시지가 발생하면서 앱이 실행되지 않는 상황이 됩니다이는 다음과 같은 단계로의 iPhone 설정을 통하여 해결할 수 있습니다설정법iPhone 설정 - 일반 - VPN 및 기기 관리에 들어갑니다해당하는 개발자 앱에 들어갑니다. ‘신뢰하지 않음’이라는 키워드를 확인할 수 있습니다그 후 파란색 바탕의 ‘Apple Development: ~~~’ 를 클릭해 줍니다다음과 같이 창에서 신뢰 버튼을 누르면 정상적으로 실행됩니다" }, { "title": "iOS | 앱의 시작 화면 구성하기 (Launch Screen)", "url": "/ios/app/9/", "categories": "iOS, APP", "tags": "launchscreen", "date": "2022-03-06 01:00:00 +0900", "snippet": "앱의 시작 화면 구성하기 (Launch Screen)시작 화면이란 앱의 첫번째 화면으로 애플의 공식 문서에 따르면, 앱이 빠르고 반응이 좋다는 인상을 남기기 위한 화면입니다앱을 신속하게 실행하고 즉시 사용할 수 있다는 인식을 향상시키기 위한 것이라고 합니다카카오톡을 켜면, 다음과 같은 화면이 나오는데 이 또한 LaunchScreen에 해당하는 부분입니다단순 내가 실행시키는 앱을 광고하거나 보여주는 용도로만 사용되는 것은 아니며 앱의 초기 설정(다양한 서비스 구성, 초기화 작업 및 필요한 요소들을 불러오는 작업이나 각종 서비스를 연결하는 작업) 등을 실행하는 초기의 단계로도 볼 수 있습니다Launch Screen 사용하기대부분 프로젝트를 만들게 되면, 다음과 같이 LaunchScreen.storyboard라는 파일이 기본적으로 만들어집니다이는 프로젝트의 설정에서 App Icons and Launch Image 에서 Launch Screen File 에서 앱의 Launch Screen 파일을 연결시킬 수 있습니다본격적으로 LaunchScreen.storyboard 파일을 살펴보면다음과 같이 뷰 컨트롤러가 존재하고 여기에 Launch Screen을 구성해 주면 됩니다저는 테스트를 위하여 다음과 같이 background color를 파란색으로 설정하였고, Label을 배치하여 실행시켜 보았습니다실행을 시켜 보았더니, 약 1초가 안되는 시간동안 잠깐 Launch Screen이 등장하고 main으로 넘어가는 것을 볼 수 있었고 저는 Launch Screen이 보여지는 시간을 조금 늘려보고자 합니다Launch Screen 딜레이 주기프로젝트 파일 안에 있는 AppDelegate.swift 파일을 열면다음과 같이 첫번째에 didFinishLaunchingWithOptions 인자를 가진 메서드가 존재합니다이 메서드는 프로그램이 실행될 준비가 완료되면 true를 반환하는 메서드입니다따라서 이 메서드에서 true를 리턴하는 시간을 sleep() 메서드를 통하여 지연시키면 Launch Screen이 노출되는 시간을 지연시킬 수 있게 됩니다func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -&amp;gt; Bool { // Override point for customization after application launch. sleep(2) return true}저는 다음과 같이 sleep(2) 메서드를 이용하여 2초동안 지연되도록 하였습니다실행 결과 정상적으로 작동됨을 확인하였습니다Referencehttps://developer.apple.com/design/human-interface-guidelines/ios/visual-design/launch-screen/https://developer.apple.com/documentation/uikit/app_and_environment/responding_to_the_launch_of_your_app" }, { "title": "iOS | 빈 공간 터치시 키보드 내려가게 하기", "url": "/ios/app/8/", "categories": "iOS, APP", "tags": "endEditing, keyboard, textfield", "date": "2022-03-05 22:00:00 +0900", "snippet": "빈 공간 터치시 키보드 내려가게 하기우리가 iOS에서 TextField에 키보드로 글을 작성하다가 빈 공간을 터치하면 키보드가 자연스럽게 내려가게 됩니다특히 iOS 특성 상 물리적 뒤로가기 키가 존재하지 않기 때문에 더 이런 부분이 중요한데요기본적으로 이 기능을 구현해주지는 않기 때문에 우리가 코드를 통하여 작성해 주어야 합니다일반적인 UIView를 사용하는 경우override func touchesBegan(_ touches: Set&amp;lt;UITouch&amp;gt;, with event: UIEvent?) { self.view.endEditing(true)}일반적인 UIView를 사용하는 환경이라면, touchesBegan이라는 메서드를 오버라이딩 하여 화면을 터치했을 때에 해야할 작업을 이 메서드 안에 집어넣어 주면 됩니다우리는 작성하기 위해 올렸던 키보드를 다시 내려야 하기 때문에 다음과 같이endEditing(true)를 호출하여 키보드가 사라지게 만들 수 있습니다tableView 혹은 ScrollView를 사용하는 경우제가 scrollView를 활용하여 앱을 구성하다가 빈 공간을 터치하면 키보드가 사라지게 만들기 위해 앞서 설명하였던 touchesBegan 메서드를 오버라이딩 하는 방법으로 구현해 보았는데 기능이 정상적으로 작동하지 않았습니다그 이유가 무엇일까 검색해 보다가 찾았던 결과는TableView나 ScrollView의 경우에는 일반적으로 스크롤을 이용하기 때문에 스크롤을 하기 위한 한번의 터치 동작이 발생하는데요, 그렇기 때문에 이를 스크롤을 하기 위한 동작으로 생각되어 무시가 된다고 합니다그렇기 때문에 touchesBegan이나 touchesMoved가 모두 호출이 되지 않는 것입니다이 경우 직접 GestureRecognizer를 추가하여 이를 캐치하도록 만들어야 합니다override func viewDidLoad() { super.viewDidLoad() view.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(tapBegan(sender:))))}@objc func tapBegan(sender: UITapGestureRecognizer) { if sender.state == .ended { self.view.endEditing(true) } sender.cancelsTouchesInView = false}다음과 같이 작성한다면, 터치가 발생하면 이를 캐치하여 키보드가 사라지게 만들 수 있습니다swift documentation을 참조하면, 탭 제스처를 인식하는 코드의 예시를 볼 수 있었고위의 코드에서 sender.cancelsTouchesInView가 무엇을 뜻하는지 알아보았는데,제스처를 인식하면 나머지 터치 정보들을 뷰로 전달하는지(false) 전달하지 않는지(true, default)를 결정하는 타입 프로퍼티임을 알 수 있었습니다자세한 정보는 https://baked-corn.tistory.com/130 이곳을 참조하였습니다Referencehttps://www.zehye.kr/ios/2020/12/11/ios_tableview_cell_touch_began/https://developer.apple.com/documentation/uikit/uitapgesturerecognizer" }, { "title": "iOS | 화면 간 데이터 전달 (1)", "url": "/ios/app/7/", "categories": "iOS, APP", "tags": "delegate, property, segue", "date": "2022-02-22 16:00:00 +0900", "snippet": "화면 간 데이터 전달 (1)보통 우리가 앱을 설계할 때, 여러가지 뷰들을 사용하고 그 뷰들 간의 데이터를 서로 주고받는 동작을 수행하도록 설계합니다처음 Swift를 접했을 때 뷰들 간의 데이터를 전달하는 많은 방법들을 보고, 그냥 뷰들 끼리 스토리보드 내에서 데이터를 공유하면 되는것 아닌가? 라는 생각을 했었습니다하지만 Swift에서는 각각의 뷰들이 개별 .nib파일로 이루어지고, 스토리보드는 이런 여러 뷰들에 대한 .nib파일을 모아둔 개념이며 각각의 뷰들은 개별 파일이기 때문에 연결할 수 있는 방법은 있지만 모든 속성을 스토리 보드 내에서 공유하는 것은 불가능 하다는 사실을 알게 되었습니다화면 간 데이터를 전달하는 방법은 다음과 같습니다 Passing Data Between View Controllers with Properties (A → B) Passing Data Between View Controllers Using Segues (A → B) Passing Data Back with Properties and Functions (A ← B) Passing Data Back with Delegation Passing Data Back with a Closure Passing Data Between View Controllers with NotificationCenter다양한 방법이 존재하지만, 이번에 설명할 방법은 총 3가지 입니다 Property를 통한 데이터 전달 Segue를 통한 데이터 전달 Delegate를 사용한 데이터 전달property를 통한 데이터 전달왼쪽(ViewController)에서 오른쪽 (CodePushViewConroller) 로의 데이터를 전달하는 방법을 알아보도록 하겠습니다먼저 데이터를 보낼 뷰 컨트롤러에 UIButton을 추가하고 @IBAction함수로 뷰 컨트롤러에 연결해 주었습니다그 후 self.storyboard?.instantiateViewController(identifier: ) 메서드를 이용하여 identifier 식별자를 가진 뷰 컨트롤러를 인스턴스화 시켜주고 옵셔널 바인딩 합니다옵셔널 바인딩 후 as? 키워드를 이용하여 앞서 리턴된 UIVIewController 클래스를 해당 클래스(CodePushViewController)로 다운 캐스팅 해 줍니다그렇게 되면, 해당 property에 접근할 수 있게 됩니다그 후 해당 클래스의 viewDidLoad 함수에서 전달받은 데이터를 활용하면 됩니다 이 방식은 Navigation Stack에 쌓이게 될 뷰 컨트롤러에 다음과 같은 property를 같이 넘긴다는 의미이기 때문에 꼭 push나 present를 하는 경우에만 데이터가 전달이 됩니다Segue를 통한 데이터 전달먼저 기존 뷰 컨트롤러와 새로운 뷰 컨트롤러 newViewController 를 생성해 주었다그 후, newViewController로 전달하기 위한 텍스트를 입력받을 텍스트필드를 생성하였고 버튼을 생성해 주었다Segue로 전달하는 방법을 알아보아야 하니 버튼을 통하여 newViewController를 Segue로 연결해 주도록 하겠다두 뷰 컨트롤러가 Segue로 연결되었다면 첫번째 뷰 컨트롤러로 돌아가서prepare 메서드를 override 해 준다prepare 메서드는 segue를 이용하여 뷰가 전환되기 직전에 호출되는 메서드이며 이 함수에서 segue.destination 키워드를 통하여 segue로 push할 때의 목적지 뷰 컨트롤러의 인스턴스로 접근할 수 있다guard let viewController = segue.destination as? newViewController else { return }먼저, 옵셔널 바인딩 그리고 newViewController로 다운캐스팅을 해주고다음과 같이 해당 인스턴스의 프로퍼티에 접근하여 데이터를 전달해주면 된다이후 newViewController의 viewDidLoad() 메서드에서다음과 같이 바인딩 해주고 전달할 부분에 전달받은 데이터를 활용해주면 된다잘 전달이 되는 것을 확인할 수 있다Delegate를 사용한 데이터 전달delegate 를 사용한 데이터 전달은 일반적으로 많이 사용하는 방식이며 꼭 알아두어야 하는 방식 중 하나입니다누가 지정해 놓은 일을 내가 대신 하는 것, 프로토콜 안에 있는 함수들을 내가 대신 처리하겠다. 이런 뜻으로 이해하면 될 것 같습니다보통 뷰 컨트롤러를 Push하면서 데이터를 넘길 때에는 Segue로 데이터를 넘기는데, 반대로 pop이 될 때에는 뷰 컨트롤러가 dismiss 되어 메모리에서 데이터가 삭제되기 때문에 Segue로 넘겨줄 수 없기 때문에 이 delegate를 많이 사용한다먼저 전달하는 뷰 컨트롤러(SendViewController 라고 가정)에서 protocol을 생성합니다protocol SendDataDelegate { func sendData(data: String)}다음과 같이, 프로토콜을 선언한 후에 메서드명과 프로퍼티명 그리고 전달할 데이터의 데이터타입을 설정해줍니다그 후 클래스 내에서 방금 생성한 프로토콜인 SendDataDelegate를 생성합니다class SendViewController: UIViewController { var delegate: SendDataDelegate?}그 후 뷰 컨트롤러가 전환되는 부분을 가진 Action 함수에서 전환하는 함수를 호출하기 직전에 다음과 같이 작성해 주면 됩니다@IBAction func tapSendButton(_ sender: UIButton) { self.delegate?.sendData(data: &quot;Hello World&quot;) self.navigationController?.popViewController(animated: true)}이제 전달하는 뷰 컨트롤러에서의 작업은 끝났고, 전달받을 뷰 컨트롤러 (ReceiveViewController 라고 가정) 에서 해야하는 작업을 정리해 보겠습니다가장 먼저 아까 생성했던 protocol을 채택합니다class ReceiveViewController: UIViewController, SendDataDelegate {}다음은 프로토콜의 요구사항을 충족시키기 위하여 아까 정의한 sendData 메서드를 구현해야 합니다클래스 내부에 구현해주면 되며 전달받은 데이터를 응용하면 됩니다func sendData(data: String) { print(&quot;\\(data)&quot;)}대부분 화면을 전환(pop)이 이루어지는 과정에서 전달이 이루어지기 때문에 그렇게 예시를 들어보겠습니다SendViewController로 push작업이 이루어지기 직전에 해당하는 prepare 메서드를 오버라이딩 하여 이용해 보겠습니다override func prepare(for segue: UIStoryboardSegue, sender: Any?) { guard let viewcontroller = segue.destination as? ReceiveViewController else { return } viewcontroller.delegate = self}다음과 같이 ReceiveViewController의 delegate, (여기서는 위임자라고 칭하겠습니다) 위임자가 자기 자신(SendViewController)이라는 것을 명시해주면 완료되는 것을 볼 수 있습니다Delegate Pattern 추가추가적으로, delegate pattern을 사용할 때 두 객체가 서로를 참조하고 있는데 이럴 경우 메모리가 해제되지 않아서 좀비로 영원히 남을 수가 있습니다 ( 메모리 누수 발생 위험 )그렇기 때문에 델리게잇을 선언할 때 weak var delegate: SendDataDeleage 와 같이 weak 키워드를 사용하는 것이 좋다고 합니다weak 키워드를 사용하기 위해서는 protocol에서 오직 이 프로토콜은 클래스에서만 사용이 가능하다는 것이 명시가 되어야 하는데, 이는 프로토콜에 클래스나 AnyObject를 상속받아 프로토콜이 오직 클래스에서만 채택이 가능하다는 것을 명시해주면 됩니다protocol이 클래스 또는 AnyObject를 상속받지 않는다면 모든 곳에서 채택이 가능합니다Referencehttps://i-colours-u.tistory.com/6https://www.appypie.com/pass-data-between-view-controllers-swift-how-to" }, { "title": "iOS | ViewController 생명 주기(Life Cycle)", "url": "/ios/app/6/", "categories": "iOS, APP", "tags": "viewcontroller, lifecycle", "date": "2022-02-15 00:00:00 +0900", "snippet": "ViewController의 Life Cycle뷰 컨트롤러에는 생명 주기(Life Cycle)가 존재하는데, 이는 화면이 전환될 때 처리해야하는 작업들을 라이프사이클에 이벤트화된 시점들을 통하여 처리할 수 있다다음과 같은 함수들이 정의되어 있다 viewDidLoad() viewWillAppear() viewDidAppear() viewWillDisappear() viewDidDisappear()화면이 전환될 때 처리해야 할 작업들을 원하는 시점에 해당하는 함수를 통하여 실행시킬 수 있다viewDidLoad()뷰가 로드 되었다뷰 컨트롤러의 모든 View 들이 메모리에 로드 되었을 때, 처음 딱 한번만 호출된다 특정 뷰 컨트롤러를 push 할 때 메모리에 로드되며 호출되지만, pop과 동시에 메모리에서 삭제되기 때문에 다시 push 하면 다시 호출된다초기화 작업을 실행하고자 할 때 많이 활용하며 클래스를 생성하면 가장 처음으로 볼 수 있는것이override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view.}인데, 뷰가 로딩되고 나서 실행할 추가적인 작업을 여기에 집어넣으면 된다viewWillAppear()뷰가 나타날 것이다뷰가 뷰 계층에 추가되고, 화면이 보이기 직전에 매번 호출된다다른 뷰로 이동했다가 되돌아오면 다시 재호출 된다는 뜻뷰와 관련된 추가적인 초기화 작업을 적어주면 된다viewDidAppear()뷰가 나타났다뷰 컨트롤러에 뷰가 뷰 계층에 추가된 후 호출된다뷰를 나타낼 때 필요한 추가 작업, 애니메이션 등viewWillDisappear()뷰가 사라질 것이다뷰가 뷰 계층에서 사라지기 전에 호출된다뷰가 생성된 뒤 작업한 내용 되돌리기 혹은 최종 데이터 저장 등viewDidDisappear()뷰가 사라졌다뷰가 뷰 계층에서 사라진 뒤에 호출된다뷰가 사라지는 것과 관련된 추가 작업 등실습위의 라이프사이클 메서드들이 언제 호출되는지 알아보기 위하여 다음과 같이 각 메서드들에 print()를 작성해 보았다프로젝트 실행루트 뷰 컨트롤러가 화면에 완전히 띄워지기까지 다음과 같은 메서드들이 순서대로 호출되었다viewDidLoad() - viewWillAppear() - viewDidAppear()다른 뷰 컨트롤러로 push다른 뷰 컨트롤러가 화면에 완전히 띄워지기까지 다음과 같은 메서드들이 순서대로 호출되었다viewWillDisappear() - viewDidDisappear()back버튼 클릭시 pop루트 뷰 컨트롤러가 완전히 띄워지기까지 다음과 같은 메서드들이 순서대로 호출되었다viewWillAppear() - viewDidAppear()이때에는 루트 뷰 컨트롤러가 다시 띄워졌음에도 불구하고 viewDidLoad()가 호출되지 않았는데, 앞서 말했던 대로 메모리에 이미 올라가있기 때문에 호출되지 않는다push되는 두번째 뷰 컨트롤러는 어떤 순서로 호출될까?두번째 뷰 컨트롤러는 pushviewController로 하고 어떤 순서로 호출되는지 알아보았다push 버튼 클릭시viewDidLoad() - viewWillAppear() - viewDidAppear()순서로 호출되었으며, 사이사이에 기존에 있던 루트 뷰 컨트롤러의 이벤트 메서드가 실행되는 것을 볼 수 있었다back버튼 클릭시 popviewWillAppear() - viewDidAppear()순서로 호출되며, 사이사이에 기존 루트 뷰 컨트롤러의 이벤트 메서드가 실행되는 것을 볼 수 있었다다시 push버튼을 눌렀을 때앞에서 루트 뷰 컨트롤러가 다시 띄워졌을 때에는 viewDidLoad() 가 호출되지 않았는데 이번에는 다시 호출되었다이유는 앞서 말했었지만, pushviewcontroller가 Navigation Stack에서 pop되면 메모리에서 지워지기 때문에 다시 push되었을 때 메모리에 다시 로드되어 viewDidLoad()가 호출된다Referencehttps://developer.apple.com/documentation/uikit/uiviewcontroller" }, { "title": "iOS | 화면 전환 방법(Code)", "url": "/ios/app/5/", "categories": "iOS, APP", "tags": "code, present, push", "date": "2022-02-13 01:00:00 +0900", "snippet": "Code를 이용한 화면 전환이번에는 코드를 이용하여 화면을 전환하는 방법을 실습해 보려고 한다먼저 다음과 같이 화면이 구성되어 있어야 한다 Navigation Controller 루트 뷰 컨트롤러와 이동할 뷰 컨트롤러 앞서 Segue 를 이용한 화면 전환에서 했었던 Cocoa Touch class 파일과 뷰 컨트롤러의 연결 루트 뷰 컨트롤러에서 클릭할 버튼 생성Code로 Push 기능 구현이후 어시스턴스를 열어 루트 뷰 컨트롤러에 버튼의 Action 을 연결해 준다코드를 이용하여 Push 할 때에는 이전 글에서 설명한 대로 Navigation Controller 의 pushViewController() 메서드를 사용해 주면 되는데 함수 원형은 다음과 같다func pushViewController(_ viewController: UIViewController, animated: Bool)이동하고자 하는 뷰 컨트롤러를 첫번째 parameter에 기입하고, 화면 전환 애니메이션 여부를 두번째 parameter에 넣어서 호출하면 된다하지만, 우리가 이 함수를 호출하기 위해서는 이동하려고 하는 CodePushViewController 를 인스턴스화 하여야 하기 때문에 다음과 같은 코드를 작성하여 인스턴스화 할 수 있다guard let viewController = self.storyboard?.instantiateViewController(identifier: ) else { return }스토리보드에 존재하는 identifier 값을 가지는 뷰 컨트롤러를 인스턴스화 할 수 있는 것이다여기서 identifier 은 다음과 같은 방법으로 확인 및 설정할 수 있다 Push 할 뷰 컨트롤러 클릭 오른쪽 메뉴에서 Show Identity inspector - Identity - Storyboard IDStoryboard ID 에 identifier 를 설정해 줄 수 있으며 나는 클래스 명과 동일한 이름으로 지정했다@IBAction func tapCodePushButton(_ sender: UIButton) { guard let viewController = self.storyboard?.instantiateViewController(identifier: &quot;CodePushViewController&quot;) else { return } self.navigationController?.pushViewController(viewController, animated: true) }그 후 다음과 같이 생성된 인스턴스를 pushViewController 의 인자로 넘겨주면 구현이 완료되며 실행하였을 때 동일하게 작동하는 것을 볼 수 있다Code로 Present 기능 구현코드로 Present 하는 것도 사용하는 메서드만 다르고 나머지는 동일하다UIButton 에 Action 함수 추가하기Storyboard ID 에 identifier 설정하기guard let viewController = self.storyboard?.instantiateViewController(identifier: &quot;CodePresentViewController&quot;) else { return }이동하고자 하는 뷰 컨트롤러를 인스턴스화 한 후에func present(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion: (() -&amp;gt; Void)? = nil)다음 present 메서드에 present할 뷰 컨트롤러, 애니메이션 여부, completion 을 적어주면 된다 첨언을 덧붙이자면, 화면 전환은 비동기 방식으로 처리되어 화면을 불러오는 작업과 동시에 다음 코드를 실행하므로 실패할 가능성이 있어 completion 인자를 활용하여 처리하는 것이 좋다고 한다@IBAction func tapCodePresentButton(_ sender: UIButton) { guard let viewController = self.storyboard?.instantiateViewController(identifier: &quot;CodePresentViewController&quot;) else { return } self.present(viewController, animated: true, completion: nil) }실행해 보면, 새로운 뷰 컨트롤러가 present 되는 것을 확인할 수 있다" }, { "title": "iOS | 화면 전환 방법(Segue)", "url": "/ios/app/4/", "categories": "iOS, APP", "tags": "segue, present, push", "date": "2022-02-13 01:00:00 +0900", "snippet": "Segue를 이용한 Push, Present다음과 같이 네비게이션 컨트롤러와 루트 뷰 컨트롤러를 연결한 후실습할 Push버튼과 Present 버튼을 루트 뷰 컨트롤러에 추가하고, 이동하게 할 새로운 뷰 컨트롤러를 추가해 준다Segue를 이용한 Push굉장히 간단한데, Push 버튼을 오른쪽 마우스 버튼을 누르면서 새로운 뷰 컨트롤러 쪽으로 드래그 하면 된다그러면 다음과 같은 화면이 나오는데, Show 를 클릭해 주면 연결이 완료된다프로젝트를 실행시켜 결과를 확인해보면, Segue Push 버튼을 누를 때 지정한 뷰 컨트롤러로 이동하는 것을 볼 수 있다이번에는 기존 뷰 컨트롤러로 돌아가는 Back 버튼을 새로운 뷰 컨트롤러에 직접 만들어 보겠다버튼을 새로운 뷰 컨트롤러에 삽입하고, File -&amp;gt; New File -&amp;gt; Cocoa Touch Class 로 새로운 파일을 생성한다다음과 같이 지정해 주고, Next 를 눌러 SeguePushViewController 클래스 생성을 완료한다만들었다면, 기존에 만들었던 뷰 컨트롤러와 새로 만든 클래스를 연결해야 한다표시한 순서대로 접근하여 새로 만든 클래스와 기존 뷰 컨트롤러를 연결시켜주는 작업을 완료한다그 후 Assistant 를 열고 새로 추가한 버튼의 Action 을 연결해 준다@IBAction func tapBackButton(_ sender: UIButton) {}우리는 Navigation Controller 의 Push 를 이용하여 화면을 전환하였으므로 네비게이션 스택에서 뷰 컨트롤러를 Pop 해주어야 하기 때문에@IBAction func tapBackButton(_ sender: UIButton) { self.navigationController?.popViewController(animated: true)}다음과 같이 navigationController 의 popViewController 메서드를 이용하여 Back 기능을 구현할 수 있다Push, Pop 은 Navigation Controller 의 Navigation Stack 을 이용하기 때문에, self.navigationController 키워드를 통하여 접근한다또한, navigationController 는 옵셔널이기 때문에 ? 키워드를 반드시 붙여 주어야 하며, animated 는 화면 전환 애니메이션을 사용할것인지 여부를 의미한다Segue를 이용한 Present새로운 View Controller를 만들고, 이번에는 만들어 놓았던 Segue Present 버튼을 이용하여 새로운 뷰 컨트롤러로 Present 되도록 실습해 보겠다위와 동일하게 마우스 오른쪽 클릭을 한 채로 새로운 뷰 컨트롤러로 드래그 앤 드랍 하고 Present Modally 를 클릭해 주면 연결이 완료된다그러면 앞서 Present 방식에서 설명하였던 모습으로 뷰 컨트롤러가 변한 것을 볼 수 있을 것이다정상적으로 작동되며, 위쪽 모서리 부분을 아래로 스와이프 하면 덮어 씌워진 뷰 컨트롤러를 제거할 수 있다이후 동일하게 뒤로가기 버튼을 구현하기 위하여 새로운 Cocoa Touch Class 파일을 생성하고 이름은 SeguePresentViewController 로 설정해 준다뷰 컨트롤러와 SeguePresentViewController 클래스를 연결, 버튼 삽입 후 Action 연결을 마친 후@IBAction func tapBackButton(_ sender: UIButton) { self.presentingViewController?.dismiss(animated: true, completion: nil)}다음과 같이 dismiss 함수를 이용하여 이전 뷰 컨트롤러로 되돌아갈 수 있으며, popViewController 와 동일하게 animated 는 화면 전환 애니메이션 여부를 의미한다여기서 completion 은 화면 전환이 완료된 이후에 실행될 메서드를 작성해주면 된다 (없다면 nil)Present 방식에서 살짝 화면 위가 남아있는 형태를 띄고 있는데, 이를 없애고 Full Screen으로도 수정할 수 있다빨간색 동그라미친 SeguePresentViewController 와 연결된 Segue를 클릭한 다음, 오른쪽 메뉴에서 Presentation 속성을 Full Screen으로 바꾸어 주면다음과 같이 Full Screen으로 Present 되는 것을 볼 수 있다" }, { "title": "iOS | 화면 전환 방식(push, present)", "url": "/ios/app/3/", "categories": "iOS, APP", "tags": "NavigationController, segue, ViewController, present, push", "date": "2022-02-12 22:00:00 +0900", "snippet": "화면 전환 방식(push, present)다양한 서비스를 제공하기 위해서 애플리케이션은 다양한 화면을 이용자에게 제공해야 한다단일 화면에서 여러개의 뷰를 이용한 화면 전환과 화면 간 데이터를 주고받는 과정은 필수적이라고 할 수 있다iOS 설정 어플리케이션에 들어가면 다음과 같은 화면을 볼 수 있는데 이 또한 Navigation Controller 를 이용한 화면 전환 방식을 취하고 있다다음 두 가지 방식이 대표적인 화면 전환의 방식이다Push 화면이 가로 방향으로 전환되며 스택의 구조를 가진다 (Navigation Stack 이라고 불림) 상단의 Back Navigation Item 이 자동으로 생성되며 누르면 기존 뷰 컨트롤러로 되돌아 간다 (pop 과정) Left Edge Swipe(화면 왼쪽 모서리를 스와이프) 방식을 통해서도 이전 화면으로 되돌아 갈 수도 있음 LIFO(Last In First Out) : 후입선출 방식의 앞서 말한 네비게이션 스택을 활용 UINavigationController 클래스의 메서드를 이용한다Present 화면이 세로 방향으로 전환되며(default) Navigation Controller 위에 새로운 뷰 컨트롤러가 덮어지게 됨 Push 방식과 같이 Back 버튼은 생성되지 않으며, Default는 위쪽 가장자리 부분을 아래로 쓸어내리면 기존 뷰 컨트롤러로 되돌아갈 수 있다 UIViewController 클래스의 메서드를 이용한다화면 전환 방법View 위에 다른 View 를 가져와 바꿔치기 메모리 누수 위험이 있어 사용되지 않음View Controller 에서 다른 View Controller 를 호출하여 전환 이동할 화면의 View Controller 를 덮는 방식 present, dismiss 이용 비동기 방식 처리Navigation Controller 를 사용하여 화면 전환하기 View Controller 의 전환을 컨트롤 Navigation Stack 으로 자식 뷰 컨트롤러를 관리 pushViewController, popViewController 이용화면 전환용 객체 Segue를 이용한 화면 전환 Storyboard 만으로 화면 전환 가능 Action Segue : 버튼 터치, 소스코드 추가 안해도 가능 Show (Navigation Controller 이용시 Push, 없다면 Present 이용) Show Detail : iPad OS에서 이용 Present Modally : present 방식으로 처리 Present As Popover : iPad OS에서 이용 Manual Segue : 수동으로 처리해주는 Segue" }, { "title": "Algorithm | 백준 11653번 소인수분해", "url": "/algorithm/prob/1/", "categories": "Algorithm, prob", "tags": "11365, algorithm, baekjoon", "date": "2022-02-11 20:00:00 +0900", "snippet": "BAEKJOON ONLINE JUDGE - 11653번 소인수분해 solved : JAVA문제정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.입력첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.출력N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.첫번째 풀이isPrime() 메서드를 만들어서 소수인지 판별하고, 반복문을 돌며 소수인 수로 나누어보고 나누어진다면 몫을 자기 자신으로 대치하는 방법을 이용하는 1차원적인 생각으로 풀어보았다 결과 : 시간 초과import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static boolean isPrime(int num) { if(num == 1) return false; for(int i=2; i&amp;lt;num; i++) { if(num % i == 0) return false; } return true; } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); while(true) { if(N == 1) break; for(int i=2; i&amp;lt;N; i++) { if(isPrime(N)) { System.out.println(N); return; } if(isPrime(i)) { while(N % i == 0) { System.out.println(i); N = N / i; } } } } }}두번째 풀이두 번째 풀이는 에라토스테네스의 체 알고리즘을 이용하여 전역 boolean타입의 배열을 선언하고 미리 소수인 수를 계산해 놓는다계산된 값들은 소수임을 판별하는 지표가 되고 이를 통해 소인수분해를 해 나간다 결과 : 정답(264ms)import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { static boolean primeN[]; static void isPrime() { primeN[0] = primeN[1] = true; for(int i=2; i&amp;lt;primeN.length; i++) { if(!primeN[i]) { for(int j=i+i; j&amp;lt;primeN.length; j=j+i) { primeN[j] = true; } } } } public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); primeN = new boolean[N+1]; isPrime(); int i=2; while(true) { if (N == 1) break; if(primeN[i]) { i++; continue; } if(N%i == 0) { System.out.println(i); N = N / i; } else i++; } }}세번째 풀이세 번째 풀이는 소인수분해를 직접 계산하되, 조건을 이용하여 불필요한 계산을 줄여 보았다두번째 경우인 N=9991 일때 에서, M은 2부터 96까지의 반복문을 돌며 M을 1씩 늘려갔을 것이다M이 97이 될 때, 첫번째 조건문이 만족이 되며 N은 M으로 나눈 몫인 103이 될 것이다그렇다면 여기서 M을 어디까지 증가시켜야 하는지에 대한 의문이 들었다이는 곰곰히 생각해보고 얻은 결론인데, 소인수도 그 수의 약수에 포함된다예를 들어 36의 인수들을 나열해보면 다음과 같고, 사진과 같이 대칭을 이룬다는 것을 알 수 있다대칭의 기준은 36의 제곱근인 6에 해당하며, 6의 오른쪽에 있는 수들(기준보다 큰 수들)은 모두 좌측에 있는 수들로 나누어지는 수이다이 경우 만약 N=36, M=6까지 진행한다면 모든 소인수를 찾을 수 있을 것이며 남은 수는 소수가 될 것이다또, 나의 첫번째 풀이에서 소수임을 판별하는 isPrime()함수를 작성하였었는데 이는 사실 소인수들이 반복문을 거치면서 N을 나누어 가기 때문에 그닥 좋은 알고리즘은 아니었었던 것 같다는 생각을 했다import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;public class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); int N = Integer.parseInt(br.readLine()); int M = 2; while(N&amp;gt;=M*M) { if(N%M == 0) { System.out.println(M); N /= M; } else M++; } if(N != 1) System.out.println(N); }} 결과 : 정답(128ms)Referencehttps://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4https://www.acmicpc.net/source/35229008" }, { "title": "iOS | AutoLayout, Priority", "url": "/ios/app/2/", "categories": "iOS, APP", "tags": "AutoLayout, Content Hugging, Compression Resistance", "date": "2022-02-09 00:40:00 +0900", "snippet": "AutoLayout, PriorityAutoLayoutAutoLayout은 다양한 해상도 비율에 대응하기 위한 개념이고, 제약 조건(Constraints)을 이용하여 뷰의 위치나 크기를 지정하는것우리가 storyboard상에서 구현한 하나의 애플리케이션 화면이 크기나 비율이 다른 기기에서도 동일한 모습을 보여주기 위하여 우리는 AutoLayout을 이용하여 구현한다 AutoLayout은 화면과의 margin, View들간의 margin, 정렬 등을 이용한다Add New Constraints 를 통하여 제약조건을 추가할 수 있으며 위 선택된 Label은 상, 하, 좌, 우로 24만큼의 margin을 가지고 AutoLayout을 구성하고 있는 것을 확인할 수 있다참고로 기준점은 나와 가까운 곳에 위치한 Object를 기준으로 하며 상(Top), 하(Bottom), 좌(Leading), 우(Trailing) 으로 표현한다Top에 설정된 Constraints를 예시로 보면, 가장 가까운 Object인 Safe Area를 기준으로 24만큼 떨어진 곳에 위치함을 알 수 있는데 Safe Area란 상태바(Status Bar), 내비게이션 바(Navigation Bar), 탭바(Tabbar) 등에 의해서 View가 가려지지 않기 위해서 제공 되던 시스템적인 마진을 뜻함따라서 위와 같은 방식으로 AutoLayout을 구성할 수 있다Priority우리는 앞에서 각 요소들 간의 margin의 Constraints(제약) 을 통하여 AutoLayout을 구성하였다Priority는 여러 제약조건들을 설정하여 구성하는데, 이들 서로 충돌이 일어날 때 어떤 Object를 우선순위가 되는지를 결정한다우선순위는 1부터 1000까지의 임의의 수를 통하여 부여할 수 있으며, 숫자가 높을 수록 우선순위가 높음을 의미하며 Horizontal 과 Vertical 값을 각각 지정할 수 있다Content Hugging PriorityContent Hugging Priority는 오브젝트가 원래의 사이즈보다 더 늘어나게 될 때 사용한다Priority가 높다는 것은 여기서는 크기 증가에 대한 저항성같은 개념으로 생각하였다 Priority값이 크면 : 크기 유지 Priority값이 작으면 : 크기 늘어남공간이 남을 때 어떤 오브젝트가 커질 지 결정하는 것이 Content Hugging Priority 이다위의 사진은 각 Label의 Constraints를 Top과 Bottom은 49, Leading과 Trailing은 각각 30으로 설정하였더니다음과 같이 오른쪽의 Label이 Leading과 Trailing Constraint를 모두 만족시킬 수 없어 두 Label중 하나는 크기가 늘어나야 하는 상황이 발생하였다이와 같은 상황에서 Content Hugging Priority가 사용되는데, 우선순위가 낮은 객체의 크기가(Width)가 증가한다 왼쪽 Label 오른쪽 Label 250 250 현재 두 Label의 Content Hugging Priority의 값은 다음과 같다 왼쪽 Label 오른쪽 Label 250 249 왼쪽 Label의 Priority가 더 크기 때문에 크기 증가에 대한 저항성을 가지므로 오른쪽 Label의 크기가 늘어나서 Constraints를 충족시킨다 왼쪽 Label 오른쪽 Label 249 250 오른쪽 Label의 Priority가 더 크기 때문에 크기 증가에 대한 저항성을 가지므로 왼쪽 Label의 크기가 늘어나서 Constraints를 충족시킨다Compression Resistance PriorityCompression Resistance Priority는 반대로 오브젝트가 원래의 사이즈보다 줄어들 때 사용한다Priority가 높다는 것은 크기 감소에 대한 저항성을 가진다는 개념으로 생각하였다 Priority값이 크면 : 크기 유지 Priority값이 작으면 : 크기 감소공간이 부족할 때 어떤 오브젝트가 더 작아질 지 결정하는 것이 Compression Resistance Priority 이다위의 사진은 각 Label의 Constraints는 위의 상황과 동일하고, 각 Label의 Text를 길게 입력시켜 공간이 부족하도록 만들었다다음과 같이 두 Label 모두 공간이 부족하여 텍스트가 생략되었고 Constraints를 충족시키지 못하기 때문에 경고가 발생한다이와 같은 상황에서 Compression Resistance Priority가 사용되는데, 우선순위가 낮은 객체의 크기가(Width)가 감소한다 왼쪽 Label 오른쪽 Label 750 750 현재 두 Label의 Compression Resistance Priority의 값은 다음과 같다 왼쪽 Label 오른쪽 Label 750 749 왼쪽 Label의 Priority가 더 크기 때문에 크기 감소에 대한 저항성을 가지므로 오른쪽 Label의 크기가 줄어들고 왼쪽 Label의 Text를 모두 보여지게 만든다 왼쪽 Label 오른쪽 Label 749 750 반대로 오른쪽 Label의 Priority가 더 크기 때문에 크기 감소에 대한 저항성을 가지므로 왼쪽 Label의 크기가 줄어들고 오른쪽 Label의 Text를 모두 보여지게 만든다" }, { "title": "iOS | UIKit 기초 알아보기", "url": "/ios/app/1/", "categories": "iOS, APP", "tags": "UIKit, UIViewController", "date": "2022-02-06 20:40:00 +0900", "snippet": "UIKit 기초 알아보기Cocoa Touch FrameworkCocoa Touch Framework는 iOS 개발을 위한 최상위 프레임워크이며, 대부분의 클래스 객체들이 모두 이 코코아터치 프레임워크에 속한다 Framework : 여러 기능을 가진 클래스와 라이브러리가 특정 결과물을 구현하고자 합쳐진 형태 (라이브러리보다 상위 그룹)아래에서 설명할 UIKit, Foundation 을 비롯하여 CoreData, MapKit 등의 Framework들을 포함하고 있는 최상위 Framework로 iOS 등의 애플 기기에서 구동되는 Application을 개발하기 위해 사용하는 통합 프레임워크를 말한다 참고로 Cocoa Framework는 MacOS의 Application을 개발하기 위해 사용되는 통합 프레임워크로, UIKit대신 AppKit이 포함된다UIKitConstruct and manage a graphical, event-driven user interface for your iOS or tvOS app. - 애플 공식 문서 iOS 또는 tvOS 앱용 그래픽 이벤트 기반 사용자 인터페이스를 구성하고 관리합니다UIKit은 Cocoa Touch를 구성하는 framework들 중 하나로 iOS 애플리케이션의 사용자 인터페이스, 이벤트 처리 및 관리, 애니메이션 등등의 핵심 오브젝트를 지원하는 프레임워크(Framework)이며 다음과 같은 기능들을 담당한다 event handling drawing and printing image-handling text management and display search support accessibility support app extension support resource managementUI~~가 붙은 클래스들을 사용하려면 반드시 UIKit을 import해야 한다Foundation가장 기본적이고, 필수적인 기능을 정의한 framework앱 개발을 위한 기반 기능들을 제공하며 데이터타입, 콜렉션 등을 구현한다다양한 용어들UIViewController, UIView최상단에 존재하는 View Controller는 iOS에서 가장 기본이 되는 컨트롤러로서 화면 하나를 관리하는 단위를 뜻하며 뷰 컨트롤러에 해당하는 UIKit 프레임워크의 클래스는 UIViewController이다 데이터 변경에 대한 응답으로 View의 내용을 업데이트 View와 사용자 상호 작용에 응답 View의 크기 조정 및 전체 Interface Layout 관리그 아래 위치한 View는 화면을 구성하는 기본 클래스로, 이는 JAVA에서 GUI프로그래밍을 할 때 사용했었던 Pannel과 비슷한 의미인것 같았다View안에는 다양한 Object들을 포함할 수 있으며 View 안에 View를 넣는 것 또한 가능하다위의 이미지에서 배경인 흰색 부분은 상단의 View이며 “명언 생성기” 라고 적힌 Label 밑에 위치한 회색 배경의 Object 또한 View이다이 View는 두개의 Label을 포함한다IBOutlet &amp;amp; IBActionIBOutlet은 Storyboard에 등록한 UI Object를 코드의 변수로 접근할 수 있게 해주는 것이고,IBAction은 UI Object의 이벤트 처리 함수를 만들어주는 것이다IBOutletstoryboard에서 우측에 Assistant 를 클릭해주면 다음과 같이 왼쪽에는 storyboard, 오른쪽에는 ViewController가 위치하게 되는데내가 추가한 Object를 코드로 접근하게 하도록 Object를 왼쪽 마우스로 클릭한 후 ViewController로 드래그 해주면 된다그러면 다음과 같은 화면이 나오는데, Name에는 원하는 변수의 이름을 적어주면 되고 Storage는 아직 잘 모르지만 메모리 관련 내용으로 특수한 경우 말고는 Weak가 쓰이는 것 같다Connect를 눌러 주면 비로소 다음과 같이 IBOutlet형 변수가 만들어진 것을 볼 수 있다IBAction위와 동일한 방식으로 Button 오브젝트를 생성하여 배치한 후, 연결해 보았더니 IBAction으로 연결된 것을 알 수 있었다버튼을 눌렀을 때 액션을 만들기 위하여 간단한 코드를 작성해 보았고 실습해 보았다다음과 같이 버튼을 클릭했을 때 레이블의 text가 변경되었다" }, { "title": "Swift | Protocol과 Delegate", "url": "/ios/swift/18/", "categories": "iOS, Swift", "tags": "delegate, protocol", "date": "2022-02-05 17:30:00 +0900", "snippet": "DAY 18Protocol과 DelegateDelegationDelegation(위임) 은 클래스나 구조체가 일부 책임을 다른 유형의 인스턴스로 전달(또는 위임)할 수 있도록 하는 디자인 패턴위임된 기능은 프로토콜에서 정의하며, delegate가 위임된 기능을 제공delegate 대리자, 조력자 델리게이트로 선언된 객체는 자신을 임명한 객체의 요청으로 지정된 메서드를 통하여 처리해 줌 델리게이트 패턴 하나의 객체가 모든 일을 처리하는 것이 아니라, 처리해야 할 일중 일부를 다른 객체에 넘기는 것 보통 프로토콜을 사용프로토콜(protocol)특정 클래스와 관련없는 property, method 선언 집합 함수(method) 정의는 없음 기능이나 속성에 대한 설계도 클래스(구조체, 열거형)에서 채택(adopt)하여 메서드를 구현해야 한다 JAVA, C#의 interface C++의 abstract base class Protocol Oriented Programming(POP) 프로토콜 단위로 묶어 표현하고, extension으로 기본적인 것을 구현하여 단일 상속의 한계를 극복 Protocol 채택class 클래스명: 부모명, 프로토콜명1, 프로토콜명2 {}class 클래스명: 프로토콜명1, 프로토콜명2{}class ViewController: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {}부모 클래스가 있으면 부모 다음에 표기하며, 부모 클래스가 없으면 바로 표기 가능Protocol 정의protocol 프로토콜명 { // property 명 // method 선언 (method는 선언만 있음)}protocol 프로토콜명: 다른프로토콜1, 다른프로토콜2 { // protocol은 다중 상속도 가능}protocol SomeProtocol { var x: Int { get set } // 읽기와 쓰기가 가능 var y: Int { get } // 읽기 전용 static var tx: Int { get set } static func typeMethod() // method 선언 func random() -&amp;gt; Double}Protocol 채택, 준수protocol Runnable { var x: Int { get set } func run()}class Man: Runnable { // 채택(adopt) var x: Int = 1 // 준수(conform) func run() {print(&quot;run&quot;)} // 준수(conform)}프로토콜 채택(adopt)하고 위임ViewController클래스는 부모 UIViewController를 상속받고, UIPickerView형의 인스턴스 pickerImage를 선언class ViewController: UIViewController { @IBOutlet var pickerImage: UIPickerView!PickerView instance를 사용하기 위해 프로토콜 UIPickerViewDelegate와 UIPickerViewDataSource를 채택class ViewController: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {프로토콜 UIPickerViewDelegate와 UIPickerViewDataSource의 필수 메서드는 모두 구현해야 프로토콜을 준수(conform) ~~Delegate는 어떤 행동에 대한 반응 동작 메서드 ~~DataSource에는 데이터를 받아 뷰를 그려주는 메서드UIPickerViewDelegateoptional 키워드가 붙은 것을 알 수 있는데, 이는 앞서 배웠던 옵셔널과는 다르고, 클래스 내에 이 메서드가 필요하다면 구현하라는 선택적인 의미가 담겨 있음UIPickerViewDataSource아래 Required라는 단어가 붙은 것을 알 수 있는데, 이는 클래스 내부에 이 메서드는 반드시 구현해야 된다는 의미가 담겨 있음추가중간에 @IBOutlet키워드를 볼 수 있었는데, 이는 코드에 정의된 변수와 화면의 객체(Storyboard)를 연결하는 것@IBAction은 Event가 일어난 경우 호출되는 Action을 정의해둔 것변수나 함수를 정의할 때 두 키워드를 작성하여 storyboard에서의 컴포넌트와 연결이 가능함 Storyboard - UIKit기초 알아보기" }, { "title": "Swift | 타입 프로퍼티(Type property)", "url": "/ios/swift/17/", "categories": "iOS, Swift", "tags": "type property", "date": "2022-02-04 00:00:00 +0900", "snippet": "DAY 17타입 프로퍼티(Type property)타입 프로퍼티란?일반적으로 우리가 사용하는 instance property는 새로운 인스턴스를 생성할 때마다 각기 다른 메모리 공간을 갖는다 (다른 인스턴스와 분리된 고유한 속성 값 집합)하지만 type property는 인스턴스 수에 관계 없이 하나의 공간만 가지고 있다C의 static constant(정적 상수) 또는 static variable(정적 변수, 전역 변수)와 같은 유형으로 사용되는 것 Type properties are useful for defining values that are universal to all instances of a particular type, such as a constant property that all instances can use (like a static constant in C), or a variable property that stores a value that’s global to all instances of that type (like a static variable in C).Swift 공식 문서 - Properties클래스, 구조체, 열거형에서 사용되며 저장 타입 프로퍼티와 연산 타입 프로퍼티가 존재한다Swift - 클래스 에서 stored property와 computed property 에 대해서 공부했었는데, 이런 저장 &amp;amp; 연산 프로퍼티 앞에 static 키워드를 붙이면 저장 타입 프로퍼티와 연산 타입 프로퍼티가 되는 것저장 타입 프로퍼티 (Stored type property)저장 타입 프로퍼티(stored type property)는 항상 초기값을 가져야 한다이는 static으로 선언되는 저장 타입 프로퍼티의 경우 초기화할 때 값을 할당할 이니셜라이저가 없기 때문이다 Type property는 인스턴가 생성될 때마다 매번 생성되는 기존 property와는 다르게 한번 호출될 때 메모리에 올라가고, 그 뒤로는 생성되지 않으며 전역변수처럼 어디서든 이 타입 프로퍼티에 접근할 수 있게 됨만약 초기값을 지정해주지 않으면, 다음과 같은 오류가 발생한다type property인 name에 접근하기 위해서는 반드시 타입 이름을 통해서만 접근이 가능하다Man.name또한 위와 같이 name 프로퍼티를 최초 호출하기 전까진, 초기화 되지 않는다이는 stored type property의 기본 속성인 lazy 때문이라고 하는데, 애플 Swift 공식문서에 따르면 A lazy stored property is a property whose initial value is not calculated until the first time it is used “lazy stored property는 처음 사용되기 전까지 연산되지 않습니다”라고 하는 것을 알 수 있습니다lazy 반드시 var와 함께 쓰여야 한다 struct, class에서만 사용할 수 있다 Computed property에는 사용할 수 없다 너무 나간것 같지만, 앞서 stored type property의 기본 속성이 lazy라고 했었는데, lazy에서 반드시 var와 함께 쓰여야 한다고 적혀있는데stored type property는 var과 let 모두 사용이 가능했다 이유가 무엇일까?조금 이해하기 어렵고 아직 100% 이해하진 못했지만, 구글링 하다가 괜찮은 답변이 있어서 가져와봤다static이 아닌 저장 프로퍼티는 인스턴스 프로퍼티로, init 함수가 불리는 시점에 모든 값이 초기화가 되어야 합니다 (직접 값을 지정하든, 옵셔널 타입으로 설정하여 nil로 초기화 되든!)근데 lazy의 경우엔 초기화 단계에서 값이 없음으로 설정 되었다가, 실제 해당 프로퍼티가 불릴 때 원하는 값으로 초기화가 됩니다.따라서 lazy 프로퍼티를 let으로 선언할 경우, 초기화 단계에서 값이 없음으로 설정되어버리면 이후 실제 사용 시 값을 설정할 수 없어서 let으로 선언하지 못한 것입니다.그럼 static, 즉 타입 프로퍼티의 경우 왜 let이 가능할까요?타입 프로퍼티는 인스턴스 프로퍼티처럼 초기화 구문의 영향을 받지 않습니다! 인스턴스가 초기화 즉 init 함수가 불리든 말든 타입 프로퍼티와는 상관이 없습니다.따라서 타입 프로퍼티의 경우 초기화 구문에서 값이 없음으로 초기화 되지 않고, 실제 사용할 때 값이 초기화 되기 때문에 let으로 선언해도 문제가 없는 것입니다 출처 : 개발자 소들이 블로그연산 타입 프로퍼티 (Computed type property) class : 오버라이딩이 가능한 연산 타입 프로퍼티 static : 오버라이딩이 불가능한 연산 타입 프로퍼티연산 타입 프로퍼티는 항상 var로 선언되어야 한다 이는 Swift - 클래스(Class) 에서 참고하면 된다여기서 앞서 Swift - 접근 제어 에서 언급했었던 class 키워드에 대해 알수 있었다이는 연산 타입 프로퍼티(Computed type property)로 오버라이딩이 가능한 연산 타입 프로퍼티를 나타내는 것을 알 수 있었다" }, { "title": "Swift | 접근 제어(access control, access modifier)", "url": "/ios/swift/16/", "categories": "iOS, Swift", "tags": "access control", "date": "2022-02-02 20:00:00 +0900", "snippet": "DAY 16접근 제어(access control, access modifier)access modifier접근 속성(접근 수정자, 액세스 수정자, 액세스 지정자)는 클래스, 메서드, 멤버의 접근 가능성을 설정하는 객체 지향 언어의 키워드구성 요소를 캡슐화 하는 데 사용한다 Keyword C# C++ Java private class class and/or friend classes class protected derived classes derived classes and/or friend classes derived classes and/or within same package package - - within its package internal same assembly - - public everybody everybody everybody Access_modifiers접근 제어모듈은 코드 배포(code distribution)의 단일 유닛 앱, Framework(UiKit 등), 외부 라이브러리open, publicopen, public 접근을 통해 모듈의 모든 소스 파일 내에서 사용할 수 있으며, 정의한 모듈을 가져오는 다른 모듈의 소스파일에서도 사용할 수 있다일반적으로 Framework에 공용 인터페이스를 지정할 때는 open 또는 public 접근을 사용한다 open 접근은 클래스 및 클래스 멤버에만 적용internalinternal 접근은 해당 모듈의 모든 소스 파일 내에서 사용되지만, 해당 모듈 외부의 소스파일에서는 사용되지 않도록 한다일반적으로 App이나 Framework의 내부 구조를 정의할 때 internal 접근을 사용한다fileprivate, privatefileprivate 접근은 해당 소스 파일 내에서만 사용가능private 접근은 블록과 동일한 파일에 있는 해당 선언의 extension으로 제한한다open - public - internal - fileprivate - private접근 제어 예open class var blue: UIColor { get }open : 모듈 외부까지(클래스에만 사용) 접근 가능class : 클래스(상속 가능) 연산 타입 프로퍼티 Type Property{ get } : 읽기만 가능" }, { "title": "Swift | extension", "url": "/ios/swift/15/", "categories": "iOS, Swift", "tags": "extension", "date": "2022-02-02 19:00:00 +0900", "snippet": "DAY 15extensionextension클래스, 구조체, 열거형, protocol에 새로운 기능을 추가하는 것extension은 하위 클래스를 생성하거나 참조하지 않고 기존 클래스에 메서드, 생성자(initializer), 계산 프로퍼티 등의 기능을 추가하기 위하여 사용함 스위프트 언어의 built-in 클래스와 iOS 프레임워크에 내장된 클래스에 기능을 추가할 때, extension을 이용하면 매우 효과적임extension 기존타입이름 { // 새로운 기능}Int 자료형에 extension 이용하여 computed property 추가하기짝수인지 판별하는 isEven 과 홀수인지 판별하는 isOdd 추가하기extension Int { var isEven: Bool { return self % 2 == 0 } var isOdd: Bool { return self % 2 == 1 }}var number = 3print(number.isOdd)print(number.isEven)outputtruefalseString 자료형에 extension 이용하여 메서드 추가하기String을 Int로 변환하여 반환하는 convertToInt() 추가하기extension String { func convertToInt() -&amp;gt; Int? { return Int(self) }}var string = &quot;0&quot;string.convertToInt()extension은 protocol 채택할 때 많이 사용아래처럼 소스를 작성하면 클래스가 너무 비대해짐class ViewContrller: UIViewController, UIPickerViewDelegate, UIPickerViewDataSource {}클래스를 다음과 같이 나누면 소스가 깔끔하고 이해하기 쉬움class ViewController: UIViewController{}extension ViewController: UIPickerViewDelegate{}extension ViewController: UIPickerViewDataSource{}" }, { "title": "Swift | 상속과 initializer", "url": "/ios/swift/14/", "categories": "iOS, Swift", "tags": "inheritance, initializer", "date": "2022-01-31 17:00:00 +0900", "snippet": "DAY 14상속과 Initializer초기화 designated Initializer convenience InitializerDesignated Initializer 클래스의 주된 initializer이고 모든 property들을 초기화시킨다 초기화되지 않은 property가 있을 경우 클래스에 적어도 하나의 designated initializer를 가져야 함 Convenience Initializer secondary, supporting initializer이다 일부 property만 초기화한다(단독으로 초기화 불가능) 다른 이니셜라이저를 사용하여 초기화(initializer delegation) self.init() 다양한 방법으로 객체를 만들 수 있도록 편의를 제공하려면, init을 오버로딩 해야하고, 코드 중복이 발생하므로 이를 방지하는 역할을 한다 Swift - 클래스(Class) 에서 기본적인 생성자에 대한 개념들을 정리했었다init() Overloadingclass Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init() { age = 1 weight = 3.5 } init(age: Int, weight: Double) { self.age = age self.weight = weight }}var kim: Man = Man()kim.display()var lee: Man = Man(age:10, weight:20.5)lee.display()overloading을 통해 서로 다른 parameter를 가지는 init() 함수 2개를 구현하였다두 init() 함수 모두 designated initializer 이다Convenience initializerclass Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double) { self.age = age self.weight = weight } // designated initializer convenience init(age: Int) { self.init(age:age, weight:3.5) } // convenience initializer}var kim: Man = Man(age:10, weight:20.5)kim.display()var lee: Man = Man(age:1)lee.display()앞서 정리했던 방식대로, init() method 앞에 convenience 키워드를 붙여서 convenience initializer를 구현할 수 있고self.init()과 같은 다른 이니셜라이저를 사용하여 초기화한다class Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double) { self.age = age self.weight = weight } // designated initializer convenience init(age: Int) { self.init(age:age, weight:3.5) } // convenience initializer convenience init() { self.init(age:20, weight:60.5) } // convenience initializer}var kim: Man = Man(age:10, weight:20.5)kim.display()var lee: Man = Man(age:1)lee.display()var han: Man = Man()han.display()2개의 convenience initializer를 이용하는 예제를 작성해 보았다convenience initializer 주의사항convenience init(age: Int) { self.init() // initializer delegation(초기화 위임) self.age = age // 자신의 초기화 코드 작성} 반드시 다음과 같은 순서로 작성해야 한다 초기화 위임, self.init() 자신의 초기화 코드 initializer가 상속되는 경우자식 클래스에서 designated initializer를 만들면 부모 init()을 상속할 수 없음designated initalizer와 convenience initializer 모두 상속 자식 클래스에 designated initializer가 없는 경우 자식 클래스에 초기화가 필요한 property가 없을 경우class Student: Man { // 비어있지만 Man의 모든 것을 가지고 있음}convenience initializer만 상속하는 경우 자식 클래스에서 부모 클래스의 designated initializer를 override 하는 경우class Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double) { self.age = age self.weight = weight } // designated initializer convenience init(age: Int) { self.init(age:age, weight:3.5) } // convenience initializer}class Student: Man { var name: String override init(age: Int, weight: Double) { self.name = &quot;Kim&quot; super.init(age:age, weight:weight) }}var kim: Student = Student(age:20, weight:55.5)var lee: Student = Student(age:5)class Student에서 Man의 init(designated initializer)을 override하였고 이로 인하여 부모 클래스의 convenience initializer만 상속한다kim은 override한 init(age: Int, weight: Double) 이니셜라이저를 사용하였고lee는 Man에서 상속한 convenience init(age: Int)를 사용하게 된다super.init()을 호출해야 하는 경우자식 클래스의 init()는 다음과 같이 작성해야 한다init(매개변수) { // 자식 클래스의 property 초기화 // 부모 클래스의 designated initializer에 위임, super.init() // 나머지 초기화 소스 작성}required initializer부모 클래스의 init methodrequired init() {}자식 클래스에서 반드시 required 로 재작성 해야 함required init()을 실행시키면, super.init()이 없어도 해당 init()을 실행시켜준다" }, { "title": "Swift | 상속(Inheritance)", "url": "/ios/swift/13/", "categories": "iOS, Swift", "tags": "class, inheritance", "date": "2022-01-27 21:00:00 +0900", "snippet": "DAY 13상속(inheritance)superclass(부모 class) 와 subclass(자식 class)상속된 클래스는 부모 클래스의 모든 기능을 상속받으며, 자신만의 기능을 추가 상속받은 클래스들을 하위 클래스(subclass) 또는 자식 클래스(child class) 하위 클래스가 상속받은 클래스는 부모 클래스(parent class) 또는 상위 클래스(super class)Swift 상속단일 상속(single inheritance)Swift에서 하위 클래스는 단 하나의 부모 클래스만 상속받을 수 있음class 자식: 부모 {} 부모 클래스는 하나만 가능 콜론 다음이 여러 개이면 나머지는 프로토콜class 클래스명: 부모명, 프로토콜명{}class 클래스명: 프로토콜명{}상속은 클래스만 가능클래스, 구조체(struct), 열거형(enum), extension에 프로토콜을 채택(adopt) 할 수 있다class Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double) { self.age = age self.weight = weight }}class Student: Man { // 비어있지만 Man에 모든 것을 가지고 있음}var kim: Man = Man(age:10, weight:20.5)kim.display()var lee: Student = Student(age:20, weight:50.2)lee.display()Student 클래스는 비어있지만, lee에서 Student는 Man을 상속 받았기 때문에 Man의 property와 method를 공유한다super : 부모 메서드 호출 시 사용class Student: Man { var name: String init(age: Int, weight: Double, name: String) { self.name = name super.init(age:age, weight:weight) }}super 키워드를 통하여 부모 메서드 init initializer를 호출해 주었다override부모와 자식에 같은 메서드가 있으면 자식 우선 호출class Man { var age: Int var weight: Double func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double) { self.age = age self.weight = weight }}class Student: Man { var name: String override func display() { print(&quot;이름=\\(name), 나이=\\(age), 몸무게=\\(weight)&quot;) } init(age: Int, weight: Double, name: String) { self.name = name super.init(age:age, weight:weight) }}var lee: Student = Student(age:20, weight:65.2, name:&quot;홍길동&quot;)lee.display()부모와 자식에 display() 라는 메서드가 있어서 Student 클래스는 display() 메서드가 두 개임lee가 display()를 호출할 때, 자식클래스가 새로 만든 display() 메서드가 우선적으로 호출되려면 func 앞에 override 키워드를 쓴다" }, { "title": "Swift | 클래스(Class)", "url": "/ios/swift/12/", "categories": "iOS, Swift", "tags": "class", "date": "2022-01-25 23:00:00 +0900", "snippet": "DAY 12클래스(class)클래스 vs 객체 vs 인스턴스클래스로부터 객체를 만들고 만들어진 실제 메모리상에 할당된 객체를 instance 라고 함 인스턴스(Instance) 소프트웨어 애플리케이션을 개발하는 데 사용되는, 쉽게 사용할 수 있으며 재사용할 수 있는 기능을 가진 모듈객체의 구성 데이터 변수(data variable) or 속성(property) 함수 or 메서드(method) Theory Swift Java C++ Data Property Field Member variable Operation Method Method Member function 클래스Structures and Classes구조체와 열거형은 Value Types, 클래스는 Reference Types 일반적인 스위프트 가이드라인에서는 구조체를 사용하는 것을 더 추천한다클래스에는 있지만, 구조체에는 없는 기능 Inheritance Type casting Deinitializers클래스의 기본 구조class 새로운 클래스 이름: 부모 클래스 { // property // instance method // type method(class method)}instance method 는 객체가 호출하는 메서드를 정의type method 는 클래스가 호출하는 메서드를 정의property조건 초기값이 있거나 init을 이용하여 초기화 옵셔널 변수(상수)로 선언 property는 stored property 와 computed property 가 있음stored propertyclass Man { var age: Int var weight: Double}다음과 같이 실행하면 property의 조건을 만족하지 않기 때문에 오류가 발생한다stored property에 초기값을 주는 3가지 방법// 1. 값을 직접 지정해준다class Man { var age: Int = 1 var weight: Double = 3.5}// 2. 옵셔널 변수로 선언한다 (Optional 변수는 `nil`로 자동 초기화 되기 때문)class Man { var age: Int? var weight: Double!}// 3. initializer로 초기화class Man { var age: Int var weight: Double init() { age = 1 weight = 3.5 }}computed propertycomputed property(계산 프로퍼티)는 property가 설정되거나 검색되는 시점에서 계산 또는 파생된 값클래스, 구조체, 열거형에서 사용되며 stored property와 달리 저장 공간을 갖지 않고 다른 stored property의 값을 읽어 연산을 실행하거나, property로 전달받은 값을 다른 property에 저장한다때문에 항상 var로 선언되어야 함또한, 타입 추론을 통해 형식을 알 수 없어서, 선언할 때 자료형을 명시해야 함 값을 리턴하는 게터(getter) method 값을 대입하는 세터(setter) 메서드 gettervar manAge: Int { get { return age-1 }}어떤 stored property의 값을 연산해서 return할 것인지, return 구문이 항상 존재해야 함manAge는 계산 프로퍼티로 저장 프로퍼티 age의 값에서 1을 뺀 값으로 하겠다는 것을 뜻함setter가 없으면 get { }은 생략할 수 있으며 변경하지 않더라도 var로 선언해야 함var manAge: Int { return age-1}setterparameter로 받은 값을 어떤 stored property에 어떻게 설정할 것인지 구현setter가 있으면 get{ } 는 생략할 수 없다매개변수명은 newValue가 기본이며, parameter를 받을 때 type을 명시해주지 않는 이유는 이미 computed property를 선언할 때 타입을 반드시 명시해줬기 때문이다set(newValue) { age = newValue + 1}Shorthand Setter Declarationsetter의 매개변수명이 newValue인 경우에만 이렇게 (newValue) 생략 가능set { age = newValue + 1}getter와 setter를 갖는 computed property manAgevar manAge: Int { get { return age-1 } set { age = newValue + 1}}Methodinstance method 와 type method 가 있다instance method인스턴스 메서드 는 인스턴스에서 동작func ~~() 처럼, func keyword 앞에 아무것도 없는 경우 instance method 임class Man { var age: Int = 1 var weight: Double = 3.5 func display() { print(&quot;나이=\\(age), 몸무게=\\(weight)&quot;) }}instance 생성하기var 인스턴스명 : 클래스명 = 클래스명()var 인스턴스명 = 클래스명()() 는 default initializer(기본 생성자) 를 나타낸다다음과 같이 사용할 수 있다var kim: Man = Man()kim.display() // instance.instance methodprint(kim.age)// instance.propertytype method(class method)type method 는 클래스 레벨에서 동작하는 것으로, 클래스의 새로운 인스턴스를 생성하는 것과 같은 동작instance method 와 동일한 방법으로 선언하지만, class 나 static 키워드를 앞에 붙여서 선언함class 키워드로 만든 class method 는 자식 클래스에서 override 가능class Man { var age: Int = 1 var weight: Double = 3.5 class func tm() { print(&quot;class method&quot;) } static func stm() { print(&quot;class method&quot;) }}Man.tm()Man.stm()인스턴스 초기화하기 : init()클래스, 구조체, 열거형 인스턴스가 생성되는 시점에서 해야 할 초기화 작업생성자인스턴스가 만들어지면서 자동 호출된다init() { }designated initializer모든 property 를 다 초기화시키는 생성자 “데시그네이티드” 라고 읽음 (디자인에이티드 인줄)소멸자인스턴스가 사라질 때 자동 호출deinit{} JAVA 언어에서 배운것과 동일하게 생성자를 하나라도 직접 만들면, default initializer는 사라진다self현재 클래스 내 method 나 property 를 가리킬 때 method, property 앞에 self. 을 붙임매개변수 명과 property 명이 동일한 경우에는 구분해주기 위하여 반드시 써야함init(age: Int, weight: Double) { self.age = age self.weight = weight}method overloading : 생성자 중첩매개변수의 개수와 자료형이 다른 같은 이름의 함수를 여러개 정의한 것매개변수가 다른 두 생성자를 통해 두가지 방법으로 인스턴스를 만들 수 있다init(age: Int, weight: Double) { self.age = age self.weight = weight}init(age: Int) { self.age = age}failable initializer (실패 가능한 생성자: init?)init?(named: String)init?로 만든 인스턴스는 옵셔널형으로 만들어져서, 사용하려면 옵셔널을 언래핑해야 함오류 상황에 nil을 리턴하는 조건문이 있기 때문임 return nilclass Man { var age: Int var weight: Double init?(age: Int, weight: Double) { if age &amp;lt;= 0 { return nil } else { self.age = age } self.weight = weight } // failable initialize}var kim: Man = Man(age:10, weight:20.5)var lee: Man = Man(age:0, weight:3.5)실행시키면, 다음과 같은 오류가 발생한다error: value of optional type &#39;Man?&#39; must be unwrapped to a value of type &#39;Man&#39;이는, 인스턴스를 생성할 때 실행되는 생성자가 Optional형이기 때문에 unwrapping을 하지 않아 생기는 오류이다이는 다음과 같은 몇가지 방법으로 해결할 수 있다// 1. 옵셔널 형으로 선언 후 옵셔널 바인딩var kim: Man? = Man(age:1, weight:3.5)if let kim1 = kim { kim1.display()}// 2. 인스턴스 생성과 동시에 옵셔널 바인딩if let kim2 = Man(age:2, weight:5.5) { kim2.display()}// 3. 인스턴스 생성과 동시에 바로 강제 언래핑var kim3: Man = Man(age:3, weight:7.5)!kim3.display()// 4. 옵셔널 인스턴스를 사용시 강제 언래핑var kim4: Man? = Man(age:4, weight:10.5)kim4!.display()3번과 4번 방식으로 강제 언래핑 하는 방법은 위험함만약 age &amp;lt;= 0일 때, init?은 nil을 반환하는데, 이때 강제 언래핑을 하고 display()를 호출하면 crash가 발생함" }, { "title": "Swift | 클로저(Closure)", "url": "/ios/swift/11/", "categories": "iOS, Swift", "tags": "closure", "date": "2022-01-24 22:40:00 +0900", "snippet": "DAY 11클로저(Closure)클로저 표현식클로저란? 익명 함수 C, C++, Objective-C의 block Java Lambda function C# Delegates클로저 표현식은 독립적인 코드 블록func add(x: Int, y: Int) -&amp;gt; Int { return(x+y)}print(add(x:10, y:20))let add1 = { (x: Int, y: Int) -&amp;gt; Int in return(x+y)}print(add1(10, 20))클로저 표현식은 매개변수를 받거나, 값을 반환하도록 만들 수도 있음{(&amp;lt;매개변수 이름&amp;gt;: &amp;lt;매개변수 타입&amp;gt;, ...) -&amp;gt; &amp;lt;반환 타입&amp;gt; in // 클로저 표현식 코드}후행 클로저(trailing closure)클로저가 함수의 마지막 argument라면 마지막 매개변수 이름을 생략한 후 함수 소괄호 외부에 클로저를 구현convenience init(title: String?, style: UIAlertAction.Style, handler: ((UIAlertAction) -&amp;gt; Void)? = nil)// 일반 클로저 표현식let removeAction = UIAlertAction(title: &quot;제거&quot;, style: UIAlertAction.Style.destructive, handler: { ACTION in self.lampImg.image = self.imgRemove self.isLampOn=false})// 후행 클로저 표현let onAction = UIAlertAction(title: &quot;On&quot;, style: UIAlertAction.Style.default) { ACTION in self.lampImg.image = self.imgOn self.isLampOn=true }함수의 마지막 argument를 생략한 후 함수 소괄호 외부에 클로저를 구현하여 더 깔끔하게 표현할 수 있는 것을 볼 수 있었음다양한 클로저 표현들let add = {(val1: Int, val2: Int) -&amp;gt; Int in return val1 + val2}result = add(10, 20)일반적인 function으로 표현func math(x: Int, y: Int, cal: (Int, Int) -&amp;gt; Int) -&amp;gt; Int { return cal(x, y)}result = math(x: 10, y: 20, cal: add)closure 표현- 일반적인 closureresult = math(x: 10, y: 20, cal: {(val1: Int, val2: Int) -&amp;gt; Int in return val1 + val2})- trailing closureresult = math(x: 10, y: 20) {(val1: Int, val2: Int) -&amp;gt; Int in return val1 + val2}- 리턴형 생략 당연히 Int형으로 반환할 것을 알고 있기 때문에, -&amp;gt; Int 를 생략하여도 자동으로 만들어 준다result = math(x: 10, y: 20, cal: {(val1: Int, val2: Int) in return val1 + val2})- trailing closure, 리턴형 생략result = math(x: 10, y: 20) {(val1: Int, val2: Int) in return val1 + val2}- 매개변수 생략 및 단축인자(shorthand argument name) 사용 단축인자 $ 는 0부터 시작하며, 위치의 절대값으로 매개변수를 표현한다result = math(x: 10, y: 20, cal: { return $0 + $1})- trailing closure, 매개변수 생략 및 단축인자 사용result = math(x: 10, y: 20) { return $0 + $1}- return 생략, 매개변수 생략 및 단축인자 사용 클로저에 return 값이 있으면 마지막 줄을 리턴하므로 return 생략 가능result = math(x: 10, y: 20, cal: { $0 + $1})- trailing closure, return 생략, 매개변수 생략 및 단축인자 사용result = math(x: 10, y: 20) { $0 + $1 }" }, { "title": "Swift | 함수를 매개변수와 리턴값으로 사용(first class citizen)", "url": "/ios/swift/10/", "categories": "iOS, Swift", "tags": "function", "date": "2022-01-23 17:00:00 +0900", "snippet": "DAY 10함수(function)를 매개변수와 리턴값으로 사용함수를 자료형으로 사용스위프트는 함수를 데이터 타입처럼 처리할 수 있다다음과 같이 함수를 상수 또는 변수에 할당하는 것이 가능func inchesToFeet(inches: Float) -&amp;gt; Float { return inches * 0.0833333}let toFeet = inchesToFeetvar tmp = toFeet(10)print(tmp)var tmp2 = inchesToFeet(inches: 10)print(tmp2)함수 호출시 toFeet(10) 처럼 외부 매개변수 명을 명시하지 않아야 작동하며 상수 이름을 이용하여 호출이 가능함어떤 함수에 다른 함수를 인자로 넘겨주거나, 함수의 반환 값으로 함수를 넘겨줄 수 있음Swift 함수는 1급 객체(first class object) 또는 1급 시민(first class citizen) 다음 조건을 충족하는 객체를 1급 객체(first class object) 라고 한다 변수에 저장할 수 있다 매개변수로 전달할 수 있다 리턴값으로 사용할 수 있다 함수를 매개변수로 사용func outputConversion(converterFunc: (Float) -&amp;gt; Float, value: Float) { let result = convertFunc(value) print(&quot;Result = \\(result)&quot;)}outputConversion 의 type((Float) -&amp;gt; Float, Float) -&amp;gt; ()함수를 리턴값으로 사용func decideFunction(feet: Bool) -&amp;gt; (Float) -&amp;gt; Float { if feet { return toFeet } else { return toYards }}feet Boolean 변수가 true이면 toFeet 함수 반환하고 false이면 toYard 반환" }, { "title": "Swift | 함수 고급(function)", "url": "/ios/swift/9/", "categories": "iOS, Swift", "tags": "function", "date": "2022-01-13 13:00:00 +0900", "snippet": "DAY 09함수(function)Swift 문자열 서식(swift string format)import Foundationlet weight = 60.0let height = 170.0let bmi = weight / (height*height*0.0001)let shortenedBmi = String(format: &quot;%.1f&quot;, bmi)var body = &quot;&quot;// 이하 switch - case / if-else 로 처리shortenedBmi는 Double 형인 bmi를 소수 두번째 자리까지 표현하고, String형으로 저장한 값이 저장된다 반드시 import Foundation이 필요함 format 이니셜라이저를 사용하여 서식을 지정할 수 있다Default Argument(디폴트 매개변수) 정의 Argument : 외부 매개 변수명 Parameter : 내부 매개 변수명func sayHello(count: Int, name: String = &quot;길동&quot;) -&amp;gt; String { return (&quot;\\(name), 번호는 \\(count)&quot;)}var message = sayHello(count:100)print(message)// 길동, 번호는 100argument 사용시 argument 사용하고, 전달하지 않으면 default 사용함수로부터 여러 개의 결과 반환함수는 여러 결과 값들을 튜플로 감싸서 반환할 수 있음func converter(length: Float) -&amp;gt; (yards: Float, centimeters: Float, meter: Float) { let yard = length * 0.0277778 let centimeters = length * 2.54 let meters = length * 0.0254 return (yards, centimeters, meters)}var lengthTuple = converter(length:10)print(lengthTuple)print(lengthTuple.yards)print(lengthTuple.centimeters)print(lengthTuple.meters)output(yards: 0.277778, centimeters: 25.4, meters: 0.254)0.27777825.40.2542개의 정수를 입력받아 가감제 리턴func sss(x: Int, y: Int) -&amp;gt; (sum: Int, sub: Int, div: Double) { let sum = x+y let sub = x-y let div = Double(x)/Double(y) // 같은 자료형만 연산 가능 return (sum, sub, div)} var result = sss(x:10,y:3)print(result.sum)print(result.sub)print(result.div)print(result)output1373.3333333333333335(sum: 13, sub: 7, div: 3.3333333333333335)가변 매개변수(variadic parameter)함수가 가변 매개변수를 받는다는 것을 가리키기 위하여 세 개의 점(...)을 사용지정되지 않은 개수의 String 값을 매개변수로 받아서 콘솔에 출력func displayStrings(strings: String...) { for string in strings { print(string) }}displayStrings(strings: &quot;일&quot;, &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;)displayStrings(strings: &quot;one&quot;, &quot;two&quot;)함수를 호출할 때 매개변수의 개수를 가변적으로 입력해도 된다는 것inoutvar myValue = 10func doubleValue (value: inout Int) -&amp;gt; Int { value += value return(value)}print(myValue)print(doubleValue(value: &amp;amp;myValue))print(myValue)call by reference 하고 싶은 매개변수의 자료형 앞에 inout 사용call by reference 하고 싶은 변수에 &amp;amp; 붙여서 호출" }, { "title": "Swift | 함수 기초(function)", "url": "/ios/swift/8/", "categories": "iOS, Swift", "tags": "function", "date": "2022-01-12 20:00:00 +0900", "snippet": "DAY 08함수 기초(function)함수(function)특정 작업을 수행하는 코드 불록매개변수(parameter, 인자)와 인수(argument)는 차이점이 있음 함수 정의부의 값을 parameter, 호출시의 값은 argument라고 부름메서드(method)특정 클래스, 구조체, 열거형 내의 함수함수를 스위프트 클래스 내에 선언하면 메서드라 부름함수를 선언하는 방법func &amp;lt;함수명&amp;gt; (&amp;lt;매개변수 이름&amp;gt;: &amp;lt;매개변수 타입&amp;gt;, &amp;lt;매개변수 이름&amp;gt;: &amp;lt;매개변수 타입&amp;gt;, ...) -&amp;gt; &amp;lt;반환값 타입&amp;gt; { // function code}func sayHello() { print(&quot;Hello&quot;)}리턴값이 없으면(-&amp;gt; Void) 지정하지 않아도 된다함수의 자료형func add(x: Int, y: Int) -&amp;gt; Int { return(x+y)}add(x:10, y:20)add함수의 자료형은 print(type(of:add))(Int, Int) -&amp;gt; Int 이다내부매개변수명, 외부매개변수명 외부매개변수명(argument lable) 내부매개변수명(parameter name) func add(first x: Int, second y: Int) -&amp;gt; Int return(x+y)}add(first:10, second:20)// add(x:10, y:20)은 오류func 함수이름(외부매개변수명 내부매개변수명: 자료형) first, second : 외부 매개변수명 x, y : 내부 매개변수명func add(x: Int, y: Int) -&amp;gt; Int { return(x+y)}add(x:10, y:20)다음과 같이 외부 매개변수명을 생략하면 내부 매개변수명이 외부 매개변수명까지 겸함func add(_ x: Int, _ y: Int) -&amp;gt; Int { return(x+y)}print(add(10, 20))// 외부매개변수명 생략 가능func add(_ x: Int, with y: Int) -&amp;gt; Int { return(x+y)}print(add(10, with:20))// 첫번째 외부매개변수명만 생략하는 경우 많음// 두번째 매개변수부터는 외부매개변수 사용// 제일 많이 쓰는 방법#function 리터럴(literal)Swift 함수명함수명(외부매개변수명:외부매개변수명: …)#function 리터럴을 사용하여 얻을 수 있음func add(first x: Int, second y: Int) -&amp;gt; Int { print(#function) // add(first:second:) return(x+y)}outputadd(first:second:)아래 함수에서 #function의 출력결과는 무엇일까?func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&amp;gt; Int { return items.count}첫 번째 parameter에서 외부 매개변수명을 생략했기 때문에 tableView(_:numberOfRowsInSection:) 라고 할 수 있다" }, { "title": "Swift | 제어문(control flow)", "url": "/ios/swift/7/", "categories": "iOS, Swift", "tags": "for, guard, switch", "date": "2022-01-11 20:30:00 +0900", "snippet": "DAY 07제어문(control-flow)For// swift3 이후 없어진 문법for var i = 0; i&amp;lt;10; i+=1 { print(i)}// 다음과 같이 수정해야 함for i in 0..&amp;lt;10 { print(i)}For-in 반복문for-in 반복문은 컬렉션 또는 숫자 범위 내에 있는 목록을 반복for 상수명 in 컬렉션 또는 범위 { // code}다음과 같이 _ 로 참조체(i) 생략할 수 있다for _ in 1...5 { print(&quot;Hello&quot;)}배열의 항목을 접근하는 방법let names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;]for name in names { print(name)}dictionary의 항목 접근let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]for (animalName, legCount) in numberOfLegs { print(&quot;\\(animalName)s have \\(legCount) legs&quot;)}spiders have 8 legsants have 6 legscats have 4 legsrepeat-while 반복문repeat { ///} whlie (조건식)do-while이 아닌 repeat-while로 사용한다if 문for i in 1..&amp;lt;10 { if i &amp;gt; 5 { break } print(i)}2번 라인다른 프로그래밍 언어들과는 다르게, 스위프트에서는 if문 다음의 실행 코드가 한 줄이라도 괄호({})를 필수적으로 사용해야 함if문 조건에서 콤마의 의미if a &amp;lt; b &amp;amp;&amp;amp; d &amp;gt; c { print(&quot;true&quot;)}if a &amp;lt; b, d &amp;gt; c { print(&quot;true&quot;)}동일한 코드이다스위프트에서 콤마의 의미는 논리적인 AND연산의 의미와 같다guard 문guard문은 표현식이 거짓(false)로 판달될 경우에 수행될 else 절을 반드시 포함해야 함 else 절에 속한 코드는 현재의 코드 흐름을 빠져 나갈 수 있는 구문(return, break, continue, throw 구문)을 반드시 포함해야 함 또 다른 함수를 else 코드 블록 안에서 호출할 수도 있음guard &amp;lt;boolean 표현식&amp;gt; else { // 표현식이 거짓일 경우에 실행될 코드 &amp;lt;코드 블록을 빠져 나갈 구문&amp;gt;}// 표현식이 참일 경우에 실행되는 코드guard문은 기본적으로 특정 조건에 맞지 않을 경우에 현재의 함수나 반복문에서 빠져 나갈 수 있도록 하는 ‘조기 출구(early exit)’ 전략을 제공func multiplyByTen(value: Int?) { guard let number = value, number &amp;lt; 10 else { print(&quot;10보다 큼&quot;) return } print(number * 10)}multiplyByTen(value: 3)값을 unwrap하기 위하여 옵셔널 바인딩 하고, 그 값이 10보다 작은지 검사 변수를 언래핑할 수 없거나 값이 10보다 크면, else절이 실행되어 에러 메시지 출력 후 return 언래핑된 number변수를 guard문 밖에 있는 코드가 사용할 수 있음 (if문을 이용할 시 못함)if let vs guard letfunc printName(firstName: String, lastName: String?) { if let lName = lastName { print(lName, firstName) } else { print(&quot;성이 없음&quot;) } guard let lName = lastName else { print(&quot;성이 없음&quot;) return } print(lName, firstName)}printName(firstName: &quot;길동&quot;, lastName: &quot;홍&quot;)switch-case문switch 표현식 { case match1: 구문 case match2: 구문 case match3, match4: 구문 default: 구문} 각 case문 마지막에 break가 자동으로 들어있음각 case에는 최소 한가지 이상의 실행문이 들어있어야 함comma(,)를 이용하여 실행될 공통 코드로 그룹 case문을 만들 수 있음switch-case문에서의 범위 지정 매칭let num = 25let count: Stringswitch num { case 0...9: count = &quot;한자리 수&quot; case 0...99: count = &quot;두자리 수&quot; case 100...999: count = &quot;세자리 수&quot; default: count = &quot;네자리 수 이상&quot;}print(&quot;\\(count)입니다.&quot;)switch-case에서 where절 사용하기where절을 switch case에 부가적인 조건을 추가하기 위하여 사용함var temperature = 60switch (temperature) { case 0...49 where temperature % 2 == 0: print(&quot;Cold and even&quot;) case 50...79 where temperature % 2 == 0: print(&quot;Warm and even&quot;) case 80...110 where temperature % 2 == 0: print(&quot;Hot and even&quot;) default: print(&quot;Temperature out of range or odd&quot;)}if문에서는 comma(,)를 통하여 부가적인 조건을 추가(논리적인 AND) 하고, switch, catch, while, guard, for 등에서는 where을 사용하여 부가적인 조건을 추가함fallthroughswift에서는 case문 다음에 break문을 포함할 필요가 없음일치하는 case문을 만나면 자동으로 빠져나옴case별로 빠져나가지 않고 아래로 계속 내려가게 하려면 fallthrough문 사용var value = 4switch (value) { case 4: print(&quot;4&quot;) fallthrough case 5: print(&quot;5&quot;) fallthrough case 6: print(&quot;6&quot;) fallthrough default: print(&quot;7&quot;)}// 4 5 6 7" }, { "title": "Swift | 연산자(operator)", "url": "/ios/swift/6/", "categories": "iOS, Swift", "tags": "operator", "date": "2022-01-10 10:30:00 +0900", "snippet": "DAY 06연산자(Operator) 참고 자료 Operator Declarations - Apple Developer기본 할당 연산자var x: Int? // Optional Intvar y: 10 // Intx = 10 // Optional(10)x = x! + y // Optional(20)x = y // Optional(10) 할당 연산자(=)는 두 개의 피연산자를 가지고, 왼쪽에 있는 피연산자는 값이 할당되는 변수 또는 상수, 오른쪽에 있는 피연산자는 할당할 값 DAY 5에서 배웠던 Optional 변수 x는 값을 unwrapping해서 초기화시켜도 wrapping 되어 저장됨증가 연산자, 감소 연산자swift 3부터 x++, x--같은 증감 연산자를 지원하지 않음 x+=1, x-=1을 사용해야 함비교 연산자다른 것들은 다 똑같지만 == 연산자는 instance value가 같은지 검사, “equal to” === 연산자는 reference point가 같은지 검사, “idetical to”범위 연산자닫힌 범위 연산자(closed range operator) x...y x에서 시작하여 y로 끝나는 범위에 포함된 숫자 5...8 5, 6, 7, 8 반 열린 범위 연산자(half-open range operator) x..&amp;lt;y x부터 시작하여 y가 포함되지 않는 모든 숫자 5..&amp;lt;8 5, 6, 7 One-side Rangeslet names = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;]for name in names[2...] { // 2부터 시작하여 names의 끝까지 포함 print(name)}outputCDNil-Coalescing Operator (Nil합병연산자) ??옵셔널 변수 ?? nil일 때 할당되는 값옵셔널 변수의 값이 nil 이면 ?? 다음 값으로 할당됨let defaultColor = &quot;black&quot;var userDefinedColor: String? // defaults to nilvar myColor = userDefinedColor ?? defaultColor// nil이므로 defaultColor - &quot;black&quot; 할당print(myColor) // blackuserDefinedColor = &quot;red&quot;myColor = userDefinedColor ?? defaultColor// nil이 아니므로 원래 값인 &quot;red&quot; 할당print(myColor) // red추가userDefinedColor가 Optional&amp;lt;String&amp;gt;이기 때문에, 9번 line에서 myColor도 Optional&amp;lt;String&amp;gt;로 초기화될 것이라고 생각했지만, Debug 결과 type(of:myColor)에서 String이 출력되었다이는 아마 연산 과정에서 optional binding을 거치는 것으로 생각된다형 변환(type casting) : as!, as?다운 캐스팅은 부모 인스턴스를 자식 클래스로 변환하는 데 사용됨성공 확신이 있으면 as! 키워드를 사용하여 강제 변환(forced conversion) as! 키워드를 사용하여 변환이 되지 않는 경우 crash 발생성공 확신이 없으면 as? 키워드를 사용하여 안전하게 변환(Optional) as? 키워드를 사용하여 변환이 되지 않는 경우 nil을 리턴하므로, 옵셔널 타입으로 반환상속 관계가 있는 클래스들끼리만 타입 캐스팅이 가능하며, 자식 인스턴스를 부모로 캐스팅은 문제가 없음업 캐스팅은 객체를 부모 클래스의 객체로 형 변환형 변환은 성공할 것이기 때문에 보장된 변환(guaranteed conversion)let myButton: UIButton = UIButton()let myControl = myButton as UIControl자식 인스턴스인 myButton을 부모 클래스형으로 형 변환다음은 부모 클래스의 객체 myScrollView를 자식 클래스 UITextView로 다운 캐스팅let myScrollView: UIScrollView = UIScrollView()// (1)let myTextView = myScrollView as! UITextView// 부모 인스턴스 as! 자식 클래스// (2)if let myTextView = myScrollView as? UITextView { print(&quot;Type cast to UITextView succeeded&quot;)} else { print(&quot;Type cast to UITextView failed&quot;)}(2) 에서 as? 키워드로 type casting을 하였기 때문에, Optional 타입으로 반환된다그렇기 때문에, Optional binding을 통하여 myTextView 에 unwarpping된 값을 초기화 시켜줄 수 있다as! vs as?var x: Any = &quot;Hi&quot;print(x, type(of:x))x = 10var y: Int = x as! Intvar z: Int? = x as? Intprint(x, type(of:x))print(y, type(of:y))print(z, type(of:z))outputHi String10 Int10 IntOptional(10) Optional&amp;lt;Int&amp;gt;(1) x의 type은 Any이므로 처음 초기화한 값인 “Hi” 에서 String으로 결정된다(2) x가 10으로 초기화되어 Int형으로 결정된다(3) y는 x가 forced conversion 되어 형 변환이 이루어진다(4) z는 x가 Optional conversion 되어 Optional&amp;lt;Int&amp;gt; 타입으로 반환되어 변환된다타입 캐스팅 연산자 정리as 컴파일 단계에서 캐스팅이 실행되며, 그러므로 언제나 특정 type으로 캐스팅이 성공할 때만 사용이 가능 업 캐스팅 혹은 브릿징에 사용된다 (Bridging : Foundation type을 스위프트 표준 라이브러리로 캐스팅)as? 런 타임에 캐스팅하여 특정 type의 옵셔널을 반환함 성공하면 옵셔널 값을 반환, 실패하면 nil 반환 따라서 반환값은 반드시 옵셔널 타입으로 선언하여 받아야 함as! 런 타임에 특정 type으로 강제 캐스팅 캐스팅 실패할 경우 런타임 에러 발생할 수 있음 다운 캐스팅은 실패할 수도 있기 때문에, 두 가지 연산자가 있음 as? 연산자를 이용하여 다운캐스팅 하고 반환된 옵셔널 값을 if-let 구문으로 처리하는 방법이 가장 일반적인 방법 캐스팅은 실제로 인스턴스를 수정하거나 그 값을 변경하지 않으며 단순히 캐스팅 된 타입으로 해당 인스턴스를 처리 및 접근타입 검사(is)타입 검사(type check)객체가 해당 Class의 인스턴스인지 검사if myobject is MyClass { // myobject는 MyClass의 인스턴스이다}" }, { "title": "Swift | 옵셔널(Optional)", "url": "/ios/swift/5/", "categories": "iOS, Swift", "tags": "", "date": "2022-01-09 20:00:00 +0900", "snippet": "DAY 05옵셔널(optional)Int형 vs Optional Int형10Int Int형 값을 저장 var x : Int = 10Optional(10)Int?, Int! Int형 값을 저장 or 값이 없음(nil) var y : Int? = 10 var z : Int!옵셔널 타입(Optional Type) 값을 반환할 때 오류가 발생할 가능성이 있는 값은 옵셔널 타입이라는 객체로 감싸서 반환함 Int(&quot;Hi&quot;) 와 같은 경우 정수 값을 반환할 수 없으므로 nil을 반환해야 하는데, Swift 기본 자료형에서는 nil값을 저장할 수 없으므로 Optional Type으로 선언해야 함 옵셔널 타입은 변수 또는 상수에 아무런 값이 할당되지 않는 상황을 안전하게 처리하기 위한 방법 제공 옵셔널 타입 변수를 선언하기 위해서는 타입 선언부 뒤에 ? 문자를 씀 옵셔널 타입 강제 언래핑(forced unwrapping)옵셔널 변수에 값이 있으면 옵셔널로 래핑되었다(wrapped)라고 함옵셔널에 래핑된 값은 강제 언래핑(forced unwrapping)으로 풀어줌var x: Int?var y: Int = 0x = 10print(x)print(x!)print(y)outputOptional(10)100print(x)에서 x는 : Int? 옵셔널 변수로 선언되었기 때문에 출력결과 Optional(10)으로 출력된다print(x!)에서는 x가 x! 키워드로 강제 언래핑되어 출력되었기 때문에 Int형 10이 출력됨 만약 x = x+2 와 같은 연산을 시도한다면, 옵셔널 타입과 Int타입이 계산되지 않기 때문에 오류가 발생함var x: Int?x = 10if x != nil { print(x!)} else { print(&quot;nil&quot;)}출력결과 x가 강제 언래핑되어 x!인 10이 출력된다강제 언래핑(forced unwrapping) - optional binding강제 언래핑하는 또 다른 방법으로, 옵셔널 바인딩(optional binding)을 이용하여 옵셔널에 할당된 값을 임시 변수 또는 상수에 할당if let constantName = optionalName { // if not nil - run this}if var variableName = optionalName { // if not nil - run this}다음과 같은 형식으로 표현하는 것이 일반적이며, optionalName에 담긴 값을 임의의 상수 혹은 변수로 optional binding을 통해 값을 언래핑시킬 수 있음var x: Int?x = 10if let xx = x { print(xx)} else { print(&quot;nil&quot;)}var x1: Int?if let xx = x1 { print(xx)} else { print(&quot;nil&quot;)}output10niloptional Int인 x의 값을 상수 xx로 optional binding시켜 Int로 unwrapping하고 값을 출력x1은 nil이기 때문에, “nil”을 출력함여러 옵셔널 변수를 한번에 언래핑하는 방법var pet1: String?var pet2: String?pet1 = &quot;cat&quot;pet2 = &quot;dog&quot;if let firstPet = pet1, let secondPet = pet2 { print(firstPet, secondPet)} else { print(&quot;nil&quot;)}다음과 같이 if문의 comma(,)를 이용하여 여러 옵셔널 변수를 한번에 언래핑할 수 있다두 가지 옵셔널 타입옵셔널이 항상 유효한 값을 가질 경우 옵셔널이 암묵적인 언래핑(implicitly unwrapped)이 되도록 선언할 수 있다이러한 방법으로 옵셔널이 선언된다면 강제 언래핑이나 옵셔널 바인딩을 하지 않아도 값에 접근할 수 있음암묵적인 언래핑으로 옵셔널을 선언하기 위해서는 선언부에 물음표(?) 대신 느낌표(!)를 사용var x: Int?var y: Int! 스위프트 공식 문서 참조 Implicitly Unwrapped Optional일반 옵셔널 값으로 사용하려고 하지만, optional로 사용할 수 없는 경우 swift는 값을 강제로 푼다Optional로 사용되지 않으면 강제로 unwrap한다let a: Int! = 1let b: Int = alet c: Int = a!let d = alet e = a + 1print(a, b, c, d, e)print(type(of:a), type(of:b), type(of:c), type(of:d), type(of:e))outputOptional(1) 1 1 Optional(1) 2Optional&amp;lt;Int&amp;gt; Int Int Optional&amp;lt;Int&amp;gt; Inta는 implicitly unwrapped으로 옵셔널이 선언되어 타입은 Optional&amp;lt;Int&amp;gt;이지만, b에서 Optional로 사용될 수 없으므로 강제로 unrwapping 하는것을 볼 수 있다c처럼 굳이 a를 강제 언래핑 하지 않아도 사용할 수 없는 경우 강제로 unwrapping 해준다하지만 d처럼 type을 명시하지 않은 경우는 그대로 Optional 타입으로 선언된다Any와 AnyObjectAnyObject(protocol)어떠한 클래스의 객체도 저장할 수 있음클래스만 허용하며 구조체나 열거형은 허용하지 않음Any어떠한 타입도 표현할 수 있다클래스, 구조체, 열거형, 함수타입도 가능var x: Any = &quot;Hi&quot;print(x, type(of:x))x = 10print(x, type(of:x))x = 3.5print(x, type(of:x))outputStringIntDouble다음과 같이 값이 초기화될 때 마다 타입이 변한다" }, { "title": "Swift | 유용한 사이트 모음", "url": "/ios/swift/p1/", "categories": "iOS, Swift", "tags": "style", "date": "2022-01-07 10:00:00 +0900", "snippet": "Swift 공식 스타일 가이드Swift style guide-koSwift Online Compiler and DebuggerGDB Online Debugger" }, { "title": "Swift | 열거형(Enum)", "url": "/ios/swift/4/", "categories": "iOS, Swift", "tags": "enum", "date": "2022-01-02 15:00:00 +0900", "snippet": "DAY 04Enum (열거형) 표현하기EnumEnumeration(열거형) 라는 뜻을 가진 Enum은 관련 있는 데이터들이 멤버로 구성되어 있는 자료형 객체Docs.swift-enumEnum 왜 사용하는가? 원치 않는 값이 잘못 입력되는 것 방지 입력 받을 값이 한정되어 있을 때 특정 값 중 하나만 선택하게 할 때 그래서 어떻게 쓰는건데?enum School { case elementary case middle case high // case elementary, middle, high}let yourSchool = School.elementaryprint(&quot;yourSchool : \\(yourSchool)&quot;)output yourSchool : elementaryEnum 변수의 Data typeyourSchool 변수 타입은 School 타입이다.print(type(of:yourSchool))outputSchool문맥에서 타입의 추론이 가능한 시점에는 열거형 명 생략 가능var x = School.elementaryx = .highprint(x)outputhigh아래와 같은 형식으로도 표현 가능var sc : Schoolsc = .elementary이러면 어떤 형식으로도 응용이 가능하냐면switch sc { case .elementary: print(&quot;you are elementary school student&quot;) case .middle print(&quot;you are middle school student&quot;) case .high print(&quot;you are high school student&quot;)}Enum의 rawValueenum Count : Int { case a case b = 3 case c}a 의 rawValue 는 0이고, b는 3이다c의 rawValue 는 4가 된다enum School : String { case elementary = &quot;초등학교&quot; case middle = &quot;중학교&quot; case high}print(School.elementary)print(School.high)output초등학교highValue를 지정하지 않은 경우 case이름이 할당됨Enum의 Associated Valueenum Birth { case intBirth(int, int, int) case stringBirth(String)}var myBirth = Birth.intBirth(1999,12,30)myBirth = Birth.stringBirth(&quot;1999년 12월 30일&quot;)switch myBirth { case .intBirth(let year, let month, let day): print(&quot;\\(year)년 \\(month)월 \\(day)일&quot;) case .stringBirth(let str): print(str)}output1999년 12월 30일switch-case 의 두번째 .stringBirth 에서 print(str) 에 따라 출력되었음Optional 에서의 EnumOptional 이란 변수에 값이 들어있을 수도 있고, 없을 수도 있다(nil)는 표현? 라는 특수문자로 표현한다public enum Optional&amp;lt;Wrapped&amp;gt; { case none case some(Wrapped)}다음과 같이 Optional method는 swift 내에 정의되어 있다let value : Int? = nilswitch value {case .none: print(&quot;정보가 없습니다&quot;)case .some(let a) where a % 2 == 0: print(&quot;\\(a) 는 짝수 입니다.&quot;)case .some(let a) where a % 2 == 1: print(&quot;\\(a) 는 홀수 입니다.&quot;)default: print(&quot;default는 한정적인 값(열거형 등)이 아니면 반드시 작성해야 함&quot;)}Swift에서 기본 자료형을 nil로 초기화할 수 없다let value : Int = nil // cannot initializenil cannot initialize specified type &#39;Int&#39;만약 실행시킨다면, 다음과 같은 오류를 발생시킨다따라서 변수에 들어있는 값을 안전하게 꺼내 사용하기 위하여 Optional을 사용한다.그리고 위와 같이 Optional은 Enum의 한 종류로 정의되어 있음" }, { "title": "Swift | 요소 반복(foreach)", "url": "/ios/swift/3/", "categories": "iOS, Swift", "tags": "foreach", "date": "2022-01-01 00:30:00 +0900", "snippet": "DAY 03foreach 반복문 표현하기for-each자바에서는 이 개념을 배웠었는데 배열이나 컬랙션의 원소들을 탐색할 때 사용하였던 것 같다var myArray : [Int] = [0,1,2,3,4,5,6,7,8,9,10]for item in myArray { print(&quot;item : \\(item)&quot;)}myArray 정수형 배열의 원소들을 탐색하며 반복한다형태는 파이썬과 비슷 한듯 싶다for item in myArray where item &amp;gt; 5 { print(&quot;5보다 큰 수 : \\(item)&quot;)}myArray 내 원소 중 5보다 큰 원소를 반복적으로 탐색한다where keyword를 사용하여 for loop 내의 조건을 준 것을 알 수 있었다" }, { "title": "Swift | 조건문(if)", "url": "/ios/swift/2/", "categories": "iOS, Swift", "tags": "if", "date": "2021-12-30 01:00:00 +0900", "snippet": "DAY 02Swift에서 조건을 표현하는 방법조건을 표현하는 방법처음 보고 느낀것은 뭔가 파이썬 닮은거 같았다고 느꼈다사실 파이썬도 잘 알지는 못한다var onoff : Bool = falseif (onoff == true) { print(&quot;on&quot;)}if (onoff != true) { print(&quot;off&quot;)}if onoff == true { print(&quot;on&quot;)}if onoff { print(&quot;on&quot;)}if !onoff { print(&quot;off&quot;)}이런 식으로 조건문 식에 괄호 없이도 동작하는 것이 특징인 것 같았고그에 따라 ! 로 not을 표현하는 것들도 더 깔끔하게 보이는 것 같았다JAVA에서는 boolean 키워드를 사용하고,Swift에서는 bool 을 사용한다 이 차이 정도 랄까 ?" }, { "title": "Swift | var, let", "url": "/ios/swift/1/", "categories": "iOS, Swift", "tags": "let, var", "date": "2021-12-27 00:50:00 +0900", "snippet": "DAY 01var, let keyword 사용 및 차이점var, let제일 먼저 우리가 공부할 때 이 키워드를 먼저 사용하게 되는 것 같다 앞서 Java 를 공부했었을 때에는, var 키워드를 뒤따라 오는(대입시키는) 자료의 데이터타입을 몰라도 알아서 데이터타입이 결정된다 이런 식으로만 사용했었던 것 같다var : 변수var은 변수(variable) 라는 뜻을 가지고 있고, 뜻 그대로 변하는 값이라는 의미를 가지고 있다.let : 상수let은 상수(constant) 라는 뜻을 가지고 있으며, 뜻 그대로 변하지 않는 값이라는 의미를 가지고 있다.var Vscore = 90let Lscore = 80Vscore = 95Lscore = 95Lscore는 let으로 선언했기 때문에 값을 변경할 수 없음공부하다가 더 알게된 점let 한글 = &quot;hangul&quot;// 유니코드 문자를 포함한 거의 모든 문자 포함 가능var score : Int = 50: 라는 Type Annotation(유형 주석)을 사용하여 datatype을 정해줄 수 있음하지만 Swift는 언어 자체에서 초기 값을 제공하면 유추할 수 있으므로 이렇게사용하는 경우는 드물다고 함Swift는 세미콜론 을 사용하지 않는다. 하지만 한 줄에 여러 개의 별도 명령문을 작성하려면 필요함" }, { "title": "GitHub | 자주 쓰는 명령어 정리", "url": "/github/inst/1/", "categories": "Github, inst", "tags": "command", "date": "2021-12-07 19:00:00 +0900", "snippet": "GitHub를 사용하다가 찾아보면서 알게 된 GitHub command 정리!git pull 인수나 옵션 없이 실행하면 현재 로컬에 등록된 추적 중인 브랜치에 해당하는 소스 모두를 가져온다. git pull [저장소 주소] [branch] : 저장소 주소에 등록된 최신 소스를 가져와 지정한 브랜치에 저장한다. git pull 은 git fetch 와 git merge 가 하는 일을 한번에 수행한다. 아무튼 git clone 으로 Git에 있는 프로젝트를 처음 불러오고, 그 이후에는 다음 명령어 사용하여 서버에서 받아오는 작업 git pull origin branchname branch git checkout으로 branch 생성 및 변경 가능 git branch로 존재하는 branch 리스트를 알 수 있음After modification add -&amp;gt; commit -&amp;gt; push 대부분의 순서는 다음과 같고, git commit -m &quot;commit message&quot; 와 같이 커밋 메시지를 추가한다 자신의 repository에 수정사항을 반영하는 작업git push origin main git push -u branchname 을 통해 default로 push할 branch를 지정함과 동시에 push 할 수 있는듯Pull request push -&amp;gt; github repo 들어오면 Compare &amp;amp; pull request 눌러서 PR(Pull Request) 생성After PR 원본 저장소 관리자가 Merge 여부 결정 Review code -&amp;gt; Merge $ git pull (remote)$ git branch -d (sub branch) " } ]
